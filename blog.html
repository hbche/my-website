<!doctype html>
<html lang="zh-Hans" dir="ltr" class="blog-wrapper blog-list-page plugin-blog plugin-id-default" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.4.3">
<title data-rh="true">Blog title | 小车的小书屋</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://hbche.github.io/my-website/img/homepage-bg-main.png"><meta data-rh="true" name="twitter:image" content="https://hbche.github.io/my-website/img/homepage-bg-main.png"><meta data-rh="true" property="og:url" content="https://hbche.github.io/my-website/blog"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="keywords" content="hanbin, frontend, react, angular, javascript, css"><meta data-rh="true" property="og:title" content="Blog title | 小车的小书屋"><meta data-rh="true" name="description" content="Blog"><meta data-rh="true" property="og:description" content="Blog"><meta data-rh="true" name="docusaurus_tag" content="blog_posts_list"><meta data-rh="true" name="docsearch:docusaurus_tag" content="blog_posts_list"><link data-rh="true" rel="icon" href="/my-website/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://hbche.github.io/my-website/blog"><link data-rh="true" rel="alternate" href="https://hbche.github.io/my-website/blog" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://hbche.github.io/my-website/blog" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/my-website/blog/rss.xml" title="小车的小书屋 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/my-website/blog/atom.xml" title="小车的小书屋 Atom Feed"><link rel="stylesheet" href="/my-website/assets/css/styles.4e9249f1.css">
<link rel="preload" href="/my-website/assets/js/runtime~main.2bef15ca.js" as="script">
<link rel="preload" href="/my-website/assets/js/main.384afa70.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}return t}()||function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"dark")}()</script><div id="__docusaurus">
<div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/my-website/"><div class="navbar__logo"><img src="/my-website/img/logo.svg" alt="小车的小书屋" class="themedImage_ToTc themedImage--light_HNdA"><img src="/my-website/img/logo.svg" alt="小车的小书屋" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">小车的小书屋</b></a><a class="navbar__item navbar__link" href="/my-website/docs">教程</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/my-website/blog">📄 博客</a><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">📚 维基</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/my-website/frontend">前端</a></li><li><a class="dropdown__link" href="/my-website/backend">服务端</a></li><li><a class="dropdown__link" href="/my-website/database">数据库</a></li><li><a class="dropdown__link" href="/my-website/embedded">嵌入式</a></li><li><a class="dropdown__link" href="/my-website/devops">DevOps</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">👨‍💻 职业</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/my-website/roadmap">求职之路</a></li></ul></div><a class="navbar__item navbar__link" href="/my-website/journal">📽️ 日志</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/hbche/my-website/tree/main" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为暗黑模式）" aria-label="切换浅色/暗黑模式（当前为暗黑模式）" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="最近博文导航"><div class="sidebarItemTitle_pO2u margin-bottom--md">近期博客</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/my-website/blog/2023/10/27/character-encoding">计算机中的字符编码</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/my-website/blog/2023/10/27/webpack-target">Webpack 学习路线和目标</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/my-website/blog/2023/10/24/rust-generic-types_traits_lifetimes">Rust 泛型trait与生命周期</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/my-website/blog/2023/10/26/rust-package-crate-module">Rust 使用包、Crate和模块管理不断增长的项目</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/my-website/blog/2023/10/23/rust-collections">Rust 常见集合</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/my-website/blog/2023/10/19/rust-enum-pattern-matching">Rust 枚举和模式匹配</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/my-website/blog/2023/10/18/rust-structure">Rust 使用结构体组织关联数据</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/my-website/blog/2023/10/09/rust-ownership">Rust 认识所有权</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/my-website/blog/2023/10/08/ieee-754">IEEE-754标准</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/my-website/blog/2023/10/08/rust-basic">Rust 通用编程概念</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/my-website/blog/2023/09/26/rust-install">Rust 环境安装</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/my-website/blog/2023/09/08/deploy-docusaurus">通过 Github Actions 部署 docusaurus 创建的静态网站</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/my-website/blog/2023/09/04/nvm-tutorial">NVM 教程</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><meta itemprop="description" content="计算机编码学习记录"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/my-website/blog/2023/10/27/character-encoding">计算机中的字符编码</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-10-27T00:00:00.000Z" itemprop="datePublished">2023年10月27日</time> · <!-- -->阅读需 17 分钟</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://github.com/hbche" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://github.com/hbche.png" alt="Hanbin Che" itemprop="image"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/hbche" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Hanbin Che</span></a></div><small class="avatar__subtitle" itemprop="description">Front End Engineer</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><p>计算机字符编码是一种方法，用于将字符（包括字母、数字、符号和控制字符）映射到数字值，以便计算机能够处理和存储文本数据。字符编码通常将每个字符映射到唯一的数字值，以便计算机能够识别和操作文本。以下是一些常见的计算机字符编码：</p><ol><li><p><strong>ASCII 编码（American Standard Code for Information Interchange）：</strong> ASCII 是最早的字符编码标准，它使用 7 位二进制数表示 128 个字符，包括英文字母、数字、标点符号和控制字符。ASCII 编码通常使用一个字节（8 位）来表示字符，其中最高位通常不用于字符表示，而用于奇偶校验。</p><details class="details_lb9f alert alert--info details_b_Ee" data-collapsed="true"><summary>奇偶校验</summary><div><div class="collapsibleContent_i85q">字符的奇偶校验是一种错误检测技术，用于确保传输或存储的字符数据的准确性。这种校验方法通过在字符的二进制表示中添加额外的位来检测和纠正可能的传输错误。通常有两种类型的奇偶校验：奇校验和偶校验。<ol><li><strong>奇校验（Odd Parity）：</strong> 在奇校验中，校验位被设置为确保字符的二进制表示中有奇数个&quot;1&quot;位。如果字符的二进制表示中已经有奇数个&quot;1&quot;位，校验位则被设置为&quot;1&quot;，以使整个字符（包括校验位）中有奇数个&quot;1&quot;位。如果字符的二进制表示中有偶数个&quot;1&quot;位，校验位则被设置为&quot;0&quot;，以确保整个字符中有奇数个&quot;1&quot;位。</li></ol><p>例如，考虑字符 &quot;1100101&quot;，它有偶数个&quot;1&quot;位，因此在奇校验中，校验位将被设置为 &quot;1&quot;，以确保整个字符中有奇数个&quot;1&quot;位，变为 &quot;11100101&quot;。</p><ol start="2"><li><strong>偶校验（Even Parity）：</strong> 在偶校验中，校验位被设置为确保字符的二进制表示中有偶数个&quot;1&quot;位。如果字符的二进制表示中已经有偶数个&quot;1&quot;位，校验位则被设置为&quot;1&quot;，以使整个字符（包括校验位）中有偶数个&quot;1&quot;位。如果字符的二进制表示中有奇数个&quot;1&quot;位，校验位则被设置为&quot;0&quot;，以确保整个字符中有偶数个&quot;1&quot;位。</li></ol><p>例如，考虑字符 &quot;1100100&quot;，它有偶数个&quot;1&quot;位，因此在偶校验中，校验位将被设置为 &quot;1&quot;，以确保整个字符中有偶数个&quot;1&quot;位，变为 &quot;11100100&quot;。</p><p>奇校验和偶校验通常用于串行通信和存储系统中，以检测和纠正数据传输中的位错误。通过检查校验位，接收方可以确定数据是否在传输过程中发生了错误。如果校验失败，接收方可以请求重新传输数据或采取其他纠正措施，以确保数据的完整性。这种奇偶校验方法是一种简单而有效的错误检测技术，尤其适用于传输或存储较小的数据块。</p></div></div></details></li><li><p><strong>ISO-8859 编码：</strong> ISO-8859 是一系列字符编码标准，每个标准用于支持不同的字符集，例如 ISO-8859-1 用于支持拉丁字母字符集。这些编码标准通常使用 8 位字节来表示字符。</p></li><li><p><strong>UTF-8 编码（Unicode Transformation Format 8-bit）：</strong> UTF-8 是一种可变长度字符编码，用于表示 Unicode 字符集中的字符。它可以表示几乎所有世界上的字符，并且在处理英文字母等常见字符时非常节省空间。UTF-8 使用 1 到 4 个字节来表示字符，具体取决于字符的 Unicode 码点。</p><details class="details_lb9f alert alert--info details_b_Ee" data-collapsed="true"><summary>Unicode 码点</summary><div><div class="collapsibleContent_i85q">Unicode 码点是 Unicode 字符集中的每个字符所分配的唯一数字标识。每个字符都由一个整数值来表示，这个整数值就是 Unicode 码点。Unicode 字符集中的每个字符，包括字母、数字、符号、表情符号等，都有一个唯一的 Unicode 码点，用来标识和区分它们。<p>Unicode 码点通常以&quot;U+&quot;（或&quot;U-&quot;）后跟一个或多个十六进制数字表示。例如，拉丁字母 &quot;A&quot; 的 Unicode 码点是 U+0041，希腊字母 &quot;Ω&quot; 的 Unicode 码点是 U+03A9，表情符号 &quot;😀&quot; 的 Unicode 码点是 U+1F600。</p><p>Unicode 字符集包含了数百万个不同的字符，每个字符都有一个唯一的码点，以支持世界上几乎所有的书写系统和符号。Unicode 码点的范围从 U+0000 到 U+10FFFF，因此可以表示广泛的字符集，包括世界各种语言、数学符号、货币符号、表情符号等等。</p><p>通过使用 Unicode 码点，计算机系统能够处理多语言文本和复杂字符集，确保文本在不同系统和应用之间的互操作性，同时减少字符编码和字符集的混淆和冲突。这使得 Unicode 成为全球标准，用于在计算机系统和应用程序中表示文本数据。</p></div></div></details></li><li><p><strong>UTF-16 编码（Unicode Transformation Format 16-bit）：</strong> UTF-16 也用于表示 Unicode 字符，它使用 16 位编码单元来表示大多数字符，但对于一些特殊字符，需要使用 32 位编码单元（代理对）。UTF-16 通常用于 Windows 操作系统和一些编程环境。</p></li><li><p><strong>UTF-32 编码（Unicode Transformation Format 32-bit）：</strong> UTF-32 使用固定的 32 位编码单元来表示每个字符，因此不涉及可变长度编码。它通常用于某些特殊应用中，以简化文本处理。</p></li></ol><p>这些是一些常见的字符编码标准，每个标准都有其特定的用途和适用性。在文本处理和编程中，了解和正确使用适当的字符编码非常重要，以确保文本数据的正确性和一致性。</p></div><footer class="row docusaurus-mt-lg"><div class="col col--9"><b>标签：</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/my-website/blog/tags/编程">编程</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/my-website/blog/tags/编码">编码</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/my-website/blog/tags/计算机通识">计算机通识</a></li></ul></div><div class="col text--right col--3"><a aria-label="阅读 计算机中的字符编码 的全文" href="/my-website/blog/2023/10/27/character-encoding"><b>阅读更多</b></a></div></footer></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><meta itemprop="description" content="Webpack工具链学习记录"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/my-website/blog/2023/10/27/webpack-target">Webpack 学习路线和目标</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-10-27T00:00:00.000Z" itemprop="datePublished">2023年10月27日</time> · <!-- -->阅读需 3 分钟</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://github.com/hbche" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://github.com/hbche.png" alt="Hanbin Che" itemprop="image"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/hbche" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Hanbin Che</span></a></div><small class="avatar__subtitle" itemprop="description">Front End Engineer</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><p>学习 Webpack 的实现需要一步一步地了解它的核心概念和工作原理。Webpack 是一个复杂但功能强大的构建工具，用于处理和打包前端项目的各种资源，如 JavaScript、CSS、图片等。以下是一个简单的学习 Webpack 的实现的步骤：</p><ol><li><p><strong>安装 Webpack</strong>：</p><p>首先，确保在你的项目中安装 Webpack。你可以使用 npm 或 yarn 来进行安装。以下是安装 Webpack 的命令：</p><div class="language-bash codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-bash codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token function" style="color:rgb(80, 250, 123)">npm</span><span class="token plain"> </span><span class="token function" style="color:rgb(80, 250, 123)">install</span><span class="token plain"> webpack webpack-cli --save-dev</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></li><li><p><strong>创建 Webpack 配置文件</strong>：</p><p>在项目根目录中创建一个名为 <code>webpack.config.js</code> 的 Webpack 配置文件。这个文件将包含 Webpack 的构建和打包配置。</p></li><li><p><strong>了解 Webpack 核心概念</strong>：</p><ul><li><strong>入口文件（Entry）</strong>：指定 Webpack 开始构建的入口文件，通常是你应用程序的主 JavaScript 文件。</li><li><strong>输出（Output）</strong>：指定 Webpack 构建后生成的文件的输出目录和文件名。</li><li><strong>Loader</strong>：用于处理不同类型的文件，例如将 ES6 转换为 ES5，将 Sass 编译为 CSS 等。</li><li><strong>Plugin</strong>：用于执行构建过程中的各种任务，如代码压缩、资源优化等。</li><li><strong>模块（Module）</strong>：Webpack 将所有文件视为模块，包括 JavaScript、CSS、图片等，你可以使用 Loader 和 Plugin 来处理这些模块。</li><li><strong>Chunk</strong>：Webpack 将模块分割为块，可以通过代码分割和懒加载来优化应用程序性能。</li></ul></li><li><p><strong>配置 Webpack</strong>：</p><p>在 <code>webpack.config.js</code> 中配置 Webpack，定义入口文件、输出目录、Loader 和 Plugin 等。学习如何配置 Webpack 是 Webpack 学习的核心。</p></li><li><p><strong>编写 Loader 和 Plugin</strong>：</p><p>如果你的项目需要特定的转换或优化，你可能需要编写自定义 Loader 和 Plugin。了解如何编写它们，以满足项目的需求。</p></li><li><p><strong>运行 Webpack</strong>：</p><p>使用命令行工具运行 Webpack，并指定配置文件的路径。通常使用以下命令：</p><div class="language-bash codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-bash codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">npx webpack --config webpack.config.js</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></li><li><p><strong>调试和优化</strong>：</p><p>学习如何使用 Webpack 的调试工具，了解如何分析构建结果，以及如何优化构建过程和输出文件。</p></li><li><p><strong>学习 Webpack 插件和社区资源</strong>：</p><p>探索 Webpack 的生态系统，了解可以加速开发流程和提高性能的插件和工具。</p></li><li><p><strong>实际项目实践</strong>：</p><p>最好的学习是通过实际项目实践。创建一个小型项目，并使用 Webpack 来构建和打包你的应用程序。</p></li><li><p><strong>学习文档和教程</strong>：</p><p>阅读 Webpack 的官方文档和教程，以深入了解 Webpack 的各个方面。</p></li></ol><p>Webpack 的学习过程可能需要一些时间，但它是前端开发中非常重要的工具之一。逐步了解和实践，你将能够更好地掌握 Webpack，并有效地构建和管理前端项目。</p></div><footer class="row docusaurus-mt-lg"><div class="col"><b>标签：</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/my-website/blog/tags/前端">前端</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/my-website/blog/tags/工具">工具</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/my-website/blog/tags/webpack">Webpack</a></li></ul></div></footer></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><meta itemprop="description" content="记录 Rust 学习过程"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/my-website/blog/2023/10/24/rust-generic-types_traits_lifetimes">Rust 泛型trait与生命周期</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-10-26T00:00:00.000Z" itemprop="datePublished">2023年10月26日</time> · <!-- -->阅读需 36 分钟</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://github.com/hbche" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://github.com/hbche.png" alt="Hanbin Che" itemprop="image"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/hbche" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Hanbin Che</span></a></div><small class="avatar__subtitle" itemprop="description">Front End Engineer</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><p>每一个编程语言都有高效处理重复概念的工具。在 Rust 中其工具之一就是 <strong>泛型</strong>（generics）。泛型是具体类型或其他属性的抽象替代。我们可以表达泛型的属性，比如他们的行为或如何与其他泛型相关联，而不需要在编写和编译代码时知道他们在这里实际上代表什么。</p><p>同理为了编写一份可以用于多种具体值的代码，函数并不知道其参数为何值，这时就可以让函数获取泛型而不是像 <code>i32</code> 或 <code>String</code> 这样的具体类型。</p><p>首先，我们将回顾一下提取函数以减少代码重复的机制。接下来，我们将使用相同的技术，从两个仅参数类型不同的函数中创建一个泛型函数。我们也会讲到结构体和枚举定义中的泛型。</p><p>之后，我们讨论 <strong>trait</strong>，这是一个定义泛型行为的方法。trait 可以与泛型结合来将泛型限制为拥有特定行为的类型，而不是任意类型。</p><p>最后介绍 <strong>生命周期</strong><em>（lifetimes）</em>，它是一类允许我们向编译器提供引用如何相互关联的泛型。Rust 的生命周期功能允许在很多场景下借用值的同时仍然使编译器能够检查这些引用的有效性。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="提取函数来减少重复">提取函数来减少重复<a href="#提取函数来减少重复" class="hash-link" aria-label="提取函数来减少重复的直接链接" title="提取函数来减少重复的直接链接">​</a></h2><p>在介绍泛型语法之前，首先来回顾一个不使用泛型处理重复的技术：提取一个函数。当熟悉了这个技术以后，我们将使用相同的机制来提取一个泛型函数！如同你识别出可以提取到函数中重复代码那样，你也会开始识别出能够使用泛型的重复代码。</p><p>考虑一下这个寻找列表中最大值的小程序，如示例 10-1 所示：</p><p>文件名: src/main.rs</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let number_list = vec![34, 50, 25, 100, 65];</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let mut largest = number_list[0];</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    for number in number_list {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        if number &gt; largest {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            largest = number;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    println!(&quot;The largest number is {}&quot;, largest);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h5 class="anchor anchorWithStickyNavbar_LWe7" id="示例-10-1在一个数字列表中寻找最大值的函数">示例 10-1：在一个数字列表中寻找最大值的函数<a href="#示例-10-1在一个数字列表中寻找最大值的函数" class="hash-link" aria-label="示例 10-1：在一个数字列表中寻找最大值的函数的直接链接" title="示例 10-1：在一个数字列表中寻找最大值的函数的直接链接">​</a></h5><p>这段代码获取一个整型列表，存放在变量 <code>number_list</code> 中。它将列表的第一项放入了变量 <code>largest</code> 中。接着遍历了列表中的所有数字，如果当前值大于 <code>largest</code> 中储存的值，将 <code>largest</code> 替换为这个值。如果当前值小于或者等于目前为止的最大值，<code>largest</code> 保持不变。当列表中所有值都被考虑到之后，<code>largest</code> 将会是最大值，在这里也就是 <code>100</code>。</p><p>如果需要在两个不同的列表中寻找最大值，我们可以重复示例 10-1 中的代码，这样程序中就会存在两段相同逻辑的代码，如示例 10-2 所示：</p><p>文件名: src/main.rs</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let number_list = vec![34, 50, 25, 100, 65];</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let mut largest = number_list[0];</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    for number in number_list {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        if number &gt; largest {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            largest = number;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    println!(&quot;The largest number is {}&quot;, largest);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let mut largest = number_list[0];</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    for number in number_list {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        if number &gt; largest {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            largest = number;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    println!(&quot;The largest number is {}&quot;, largest);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h5 class="anchor anchorWithStickyNavbar_LWe7" id="示例-10-2寻找-两个-数字列表最大值的代码">示例 10-2：寻找 <strong>两个</strong> 数字列表最大值的代码<a href="#示例-10-2寻找-两个-数字列表最大值的代码" class="hash-link" aria-label="示例-10-2寻找-两个-数字列表最大值的代码的直接链接" title="示例-10-2寻找-两个-数字列表最大值的代码的直接链接">​</a></h5><p>虽然代码能够执行，但是重复的代码是冗余且容易出错的，并且意味着当更新逻辑时需要修改多处地方的代码。</p><p>为了消除重复，我们可以创建一层抽象，在这个例子中将表现为一个获取任意整型列表作为参数并对其进行处理的函数。这将增加代码的简洁性并让我们将表达和推导寻找列表中最大值的这个概念与使用这个概念的特定位置相互独立。</p><p>在示例 10-3 的程序中将寻找最大值的代码提取到了一个叫做 <code>largest</code> 的函数中。这不同于示例 10-1 中的代码只能在一个特定的列表中找到最大的数字，这个程序可以在两个不同的列表中找到最大的数字。</p><p>文件名: src/main.rs</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn largest(list: &amp;[i32]) -&gt; i32 {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let mut largest = list[0];</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    for &amp;item in list {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        if item &gt; largest {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            largest = item;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    largest</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let number_list = vec![34, 50, 25, 100, 65];</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let result = largest(&amp;number_list);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    println!(&quot;The largest number is {}&quot;, result);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let result = largest(&amp;number_list);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    println!(&quot;The largest number is {}&quot;, result);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h5 class="anchor anchorWithStickyNavbar_LWe7" id="示例-10-3抽象后的寻找两个数字列表最大值的代码">示例 10-3：抽象后的寻找两个数字列表最大值的代码<a href="#示例-10-3抽象后的寻找两个数字列表最大值的代码" class="hash-link" aria-label="示例 10-3：抽象后的寻找两个数字列表最大值的代码的直接链接" title="示例 10-3：抽象后的寻找两个数字列表最大值的代码的直接链接">​</a></h5><p><code>largest</code> 函数有一个参数 <code>list</code>，它代表会传递给函数的任何具体的 <code>i32</code> 值的 <code>slice</code>。函数定义中的 <code>list</code> 代表任何 <code>&amp;[i32]</code>。当调用 <code>largest</code> 函数时，其代码实际上运行于我们传递的特定值上。</p><p>总的来说，从示例 10-2 到示例 10-3 中涉及的机制经历了如下几步：</p><ol><li>找出重复代码。</li><li>将重复代码提取到了一个函数中，并在函数签名中指定了代码中的输入和返回值。</li><li>将重复代码的两个实例，改为调用函数。</li></ol><p>在不同的场景使用不同的方式，我们也可以利用相同的步骤和泛型来减少重复代码。与函数体可以在抽象 <code>list</code> 而不是特定值上操作的方式相同，泛型允许代码对抽象类型进行操作。</p><p>如果我们有两个函数，一个寻找 <code>i32</code> 值的 <code>slice</code> 中的最大项，而另一个寻找 <code>char</code> 值的 <code>slice</code> 中的最大项，该怎么办？该如何消除重复呢？让我们拭目以待！</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="泛型数据类型">泛型数据类型<a href="#泛型数据类型" class="hash-link" aria-label="泛型数据类型的直接链接" title="泛型数据类型的直接链接">​</a></h2><p>我们可以使用泛型为函数签名或结构体等项创建定义，这样它们就可以用于多种不同的具体数据类型。让我们看看如何使用泛型定义函数、结构体、枚举和方法，然后我们将讨论泛型如何影响代码性能。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="在函数定义中使用泛型">在函数定义中使用泛型<a href="#在函数定义中使用泛型" class="hash-link" aria-label="在函数定义中使用泛型的直接链接" title="在函数定义中使用泛型的直接链接">​</a></h3><p>当使用泛型定义函数时，本来在函数签名中指定参数和返回值的类型的地方，会改用泛型来表示。采用这种技术，使得代码适应性更强，从而为函数的调用者提供更多的功能，同时也避免了代码的重复。</p><p>回到 <code>largest</code> 函数，示例 10-4 中展示了两个函数，它们的功能都是寻找 <code>slice</code> 中最大值。</p><p>文件名: src/main.rs</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn largest_i32(list: &amp;[i32]) -&gt; i32 {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let mut largest = list[0];</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    for &amp;item in list {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        if item &gt; largest {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            largest = item;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    largest</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn largest_char(list: &amp;[char]) -&gt; char {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let mut largest = list[0];</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    for &amp;item in list {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        if item &gt; largest {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            largest = item;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    largest</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let number_list = vec![34, 50, 25, 100, 65];</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let result = largest_i32(&amp;number_list);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    println!(&quot;The largest number is {}&quot;, result);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let char_list = vec![&#x27;y&#x27;, &#x27;m&#x27;, &#x27;a&#x27;, &#x27;q&#x27;];</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let result = largest_char(&amp;char_list);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    println!(&quot;The largest char is {}&quot;, result);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h5 class="anchor anchorWithStickyNavbar_LWe7" id="示例-10-4两个函数不同点只是名称和签名类型">示例 10-4：两个函数，不同点只是名称和签名类型<a href="#示例-10-4两个函数不同点只是名称和签名类型" class="hash-link" aria-label="示例 10-4：两个函数，不同点只是名称和签名类型的直接链接" title="示例 10-4：两个函数，不同点只是名称和签名类型的直接链接">​</a></h5><p><code>largest_i32</code> 函数是从示例 10-3 中摘出来的，它用来寻找 <code>slice</code> 中最大的 <code>i32</code>。<code>largest_char</code> 函数寻找 <code>slice</code> 中最大的 <code>char</code>。因为两者函数体的代码一致，我们可以定义一个函数，再引进泛型参数来消除这种重复。</p><p>为了参数化新函数中的这些类型，我们也需要为类型参数取个名字，道理和给函数的形参起名一样。任何标识符都可以作为类型参数的名字。这里选用 <code>T</code>，因为传统上来说，Rust 的参数名字都比较短，通常就只有一个字母，同时，Rust 类型名的命名规范是骆驼命名法（CamelCase）。<code>T</code> 作为 “type” 的缩写是大部分 Rust 开发者的首选。</p><p>如果要在函数体中使用参数，就必须在函数签名中声明它的名字，好让编译器知道这个名字指代的是什么。同理，当在函数签名中使用一个类型参数时，必须在使用它之前就声明它。为了定义泛型版本的 <code>largest</code> 函数，类型参数声明位于函数名称与参数列表中间的尖括号 <code>&lt;&gt;</code> 中，像这样：</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T {}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>可以这样理解这个定义：函数 <code>largest</code> 有泛型类型 <code>T</code>。它有个参数 <code>list</code>，其类型是元素为 <code>T</code> 的 <code>slice</code>。<code>largest</code> 函数的返回值类型也是 <code>T</code>。</p><p>示例 10-5 中的 <code>largest</code> 函数在它的签名中使用了泛型，统一了两个实现。该示例也展示了如何调用 <code>largest</code> 函数，把 <code>i32</code> 值的 <code>slice</code> 或 <code>char</code> 值的 <code>slice</code> 传给它。请注意这些代码还不能编译，不过稍后在本章会解决这个问题。</p><p>文件名: src/main.rs</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let mut largest = list[0];</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    for &amp;item in list {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        if item &gt; largest {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            largest = item;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    largest</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let number_list = vec![34, 50, 25, 100, 65];</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let result = largest(&amp;number_list);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    println!(&quot;The largest number is {}&quot;, result);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let char_list = vec![&#x27;y&#x27;, &#x27;m&#x27;, &#x27;a&#x27;, &#x27;q&#x27;];</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let result = largest(&amp;char_list);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    println!(&quot;The largest char is {}&quot;, result);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h5 class="anchor anchorWithStickyNavbar_LWe7" id="示例-10-5一个使用泛型参数的-largest-函数定义尚不能编译">示例 10-5：一个使用泛型参数的 <code>largest</code> 函数定义，尚不能编译<a href="#示例-10-5一个使用泛型参数的-largest-函数定义尚不能编译" class="hash-link" aria-label="示例-10-5一个使用泛型参数的-largest-函数定义尚不能编译的直接链接" title="示例-10-5一个使用泛型参数的-largest-函数定义尚不能编译的直接链接">​</a></h5><p>如果现在就编译这个代码，会出现如下错误：</p><div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">PS E:\github\rust-projects\generate_type&gt; cargo run</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">   Compiling generate_type v0.1.0 (E:\github\rust-projects\generate_type)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">error</span><span class="token url-reference url punctuation" style="color:rgb(248, 248, 242)">[</span><span class="token url-reference url variable" style="color:rgb(189, 147, 249);font-style:italic">E0369</span><span class="token url-reference url punctuation" style="color:rgb(248, 248, 242)">]</span><span class="token url-reference url punctuation" style="color:rgb(248, 248, 242)">:</span><span class="token url-reference url"> binary</span><span class="token plain"> operation </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`&gt;`</span><span class="token plain"> cannot be applied to type </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`T`</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"> --&gt; src\main.rs:5:17</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">5 |         if item &gt; largest {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |            ---- ^ ------- T</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |            |</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |            T</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">help: consider restricting type parameter </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`T`</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">1 | fn largest</span><span class="token tag punctuation" style="color:rgb(248, 248, 242)">&lt;</span><span class="token tag namespace" style="color:rgb(255, 121, 198)">T:</span><span class="token tag" style="color:rgb(255, 121, 198)"> </span><span class="token tag attr-name namespace" style="color:rgb(241, 250, 140)">std:</span><span class="token tag attr-name" style="color:rgb(241, 250, 140)">:cmp::PartialOrd</span><span class="token tag punctuation" style="color:rgb(248, 248, 242)">&gt;</span><span class="token plain">(list: &amp;[T]) -&gt; T {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |             ++++++++++++++++++++++</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">For more information about this error, try </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`rustc --explain E0369`</span><span class="token plain">.</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">error: could not compile </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`generate_type`</span><span class="token plain"> (bin &quot;generate_type&quot;) due to previous error</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>注释中提到了 <code>std::cmp::PartialOrd</code>，这是一个 <em>trait</em>。下一部分会讲到 trait。不过简单来说，这个错误表明 largest 的函数体不能适用于 T 的所有可能的类型。因为在函数体需要比较 T 类型的值，不过它只能用于我们知道如何排序的类型。为了开启比较功能，标准库中定义的 <code>std::cmp::PartialOrd trait</code> 可以实现类型的比较功能。</p><p>标准库中定义的 <code>std::cmp::PartialOrd trait</code> 可以实现类型的比较功能。在 “trait 作为参数” 部分会讲解如何指定泛型实现特定的 trait，不过让我们先探索其他使用泛型参数的方法。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="结构体定义中的泛型">结构体定义中的泛型<a href="#结构体定义中的泛型" class="hash-link" aria-label="结构体定义中的泛型的直接链接" title="结构体定义中的泛型的直接链接">​</a></h3><p>同样也可以用 <code>&lt;&gt;</code> 语法来定义结构体，它包含一个或多个泛型参数类型字段。示例 10-6 展示了如何定义和使用一个可以存放任何类型的 <code>x</code> 和 <code>y</code> 坐标值的结构体 <code>Point</code>：</p><p>文件名: src/main.rs</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">struct Point&lt;T&gt; {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    x: T,</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    y: T,</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let integer = Point { x: 5, y: 10 };</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let float = Point { x: 1.0, y: 4.0 };</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    println!(&quot;The integer point is ({}, {})&quot;, integer.x, integer.y);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    println!(&quot;The float point is ({}, {})&quot;, float.x, float.y);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h5 class="anchor anchorWithStickyNavbar_LWe7" id="示例-10-6point-结构体存放了两个-t-类型的值-x-和-y">示例 10-6：<code>Point</code> 结构体存放了两个 <code>T</code> 类型的值 <code>x</code> 和 <code>y</code><a href="#示例-10-6point-结构体存放了两个-t-类型的值-x-和-y" class="hash-link" aria-label="示例-10-6point-结构体存放了两个-t-类型的值-x-和-y的直接链接" title="示例-10-6point-结构体存放了两个-t-类型的值-x-和-y的直接链接">​</a></h5><p>其语法类似于函数定义中使用泛型。首先，必须在结构体名称后面的尖括号中声明泛型参数的名称。接着在结构体定义中可以指定具体数据类型的位置使用泛型类型。</p><p>注意 <code>Point&lt;T&gt;</code> 的定义中只使用了一个泛型类型，这个定义表明结构体 <code>Point&lt;T&gt;</code> 对于一些类型 <code>T</code> 是泛型的，而且字段 <code>x</code> 和 <code>y</code> <strong>都是</strong> 相同类型的，无论它具体是何类型。如果尝试创建一个有不同类型值的 <code>Point&lt;T&gt;</code> 的实例，像示例 10-7 中的代码就不能编译：</p><p>文件名: src/main.rs</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">struct Point&lt;T&gt; {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    x: T,</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    y: T,</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let wont_work = Point { x: 5, y: 4.0 };</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h5 class="anchor anchorWithStickyNavbar_LWe7" id="示例-10-7字段-x-和-y-的类型必须相同因为他们都有相同的泛型类型-t">示例 10-7：字段 <code>x</code> 和 <code>y</code> 的类型必须相同，因为他们都有相同的泛型类型 <code>T</code><a href="#示例-10-7字段-x-和-y-的类型必须相同因为他们都有相同的泛型类型-t" class="hash-link" aria-label="示例-10-7字段-x-和-y-的类型必须相同因为他们都有相同的泛型类型-t的直接链接" title="示例-10-7字段-x-和-y-的类型必须相同因为他们都有相同的泛型类型-t的直接链接">​</a></h5><p>在这个例子中，当把整型值 <code>5</code> 赋值给 <code>x</code> 时，就告诉了编译器这个 <code>Point&lt;T&gt;</code> 实例中的泛型 <code>T</code> 是整型的。接着指定 <code>y</code> 为 <code>4.0</code>，它被定义为与 <code>x</code> 相同类型，就会得到一个像这样的类型不匹配错误：</p><div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">PS E:\github\rust-projects\generate_type&gt; cargo run</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">   Compiling generate_type v0.1.0 (E:\github\rust-projects\generate_type)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">error</span><span class="token url-reference url punctuation" style="color:rgb(248, 248, 242)">[</span><span class="token url-reference url variable" style="color:rgb(189, 147, 249);font-style:italic">E0308</span><span class="token url-reference url punctuation" style="color:rgb(248, 248, 242)">]</span><span class="token url-reference url punctuation" style="color:rgb(248, 248, 242)">:</span><span class="token url-reference url"> mismatched</span><span class="token plain"> types</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"> --&gt; src\main.rs:7:38</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">7 |     let wont_work = Point { x: 5, y: 4.0 };</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |                                      ^^^ expected integer, found floating-point number</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">For more information about this error, try </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`rustc --explain E0308`</span><span class="token plain">.</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">error: could not compile </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`generate_type`</span><span class="token plain"> (bin &quot;generate_type&quot;) due to previous error</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>如果想要定义一个 <code>x</code> 和 <code>y</code> 可以有不同类型且仍然是泛型的 <code>Point</code> 结构体，我们可以使用多个泛型类型参数。在示例 10-8 中，我们修改 <code>Point</code> 的定义为拥有两个泛型类型 <code>T</code> 和 <code>U</code>。其中字段 <code>x</code> 是 <code>T</code> 类型的，而字段 <code>y</code> 是 <code>U</code> 类型的：</p><p>文件名: src/main.rs</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">struct Point&lt;T, U&gt; {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    x: T,</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    y: U,</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let both_integer = Point {x: 5, y: 10,};</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let both_float = Point {x: 1.0, y: 4.0,};</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let integer_and_float = Point {x: 5, y: 4.0,};</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h5 class="anchor anchorWithStickyNavbar_LWe7" id="示例-10-8使用两个泛型的-point这样-x-和-y-可能是不同类型">示例 10-8：使用两个泛型的 <code>Point</code>，这样 <code>x</code> 和 <code>y</code> 可能是不同类型<a href="#示例-10-8使用两个泛型的-point这样-x-和-y-可能是不同类型" class="hash-link" aria-label="示例-10-8使用两个泛型的-point这样-x-和-y-可能是不同类型的直接链接" title="示例-10-8使用两个泛型的-point这样-x-和-y-可能是不同类型的直接链接">​</a></h5><p>现在所有的 <code>Point</code> 实例都合法了！你可以在定义中使用任意多的泛型类型参数，不过太多的话，代码将难以阅读和理解。当你的代码中需要许多泛型类型时，它可能表明你的代码需要重构，分解成更小的结构。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="枚举定义中的泛型">枚举定义中的泛型<a href="#枚举定义中的泛型" class="hash-link" aria-label="枚举定义中的泛型的直接链接" title="枚举定义中的泛型的直接链接">​</a></h3><p>和结构体类似，枚举也可以在成员中存放泛型数据类型。标准库提供的 <code>Option&lt;T&gt;</code> 枚举，这里再回顾一下：</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">enum Option&lt;T&gt; {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    Some(T),</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    None,</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>现在这个定义应该更容易理解了。如你所见 <code>Option&lt;T&gt;</code> 是一个拥有泛型 <code>T</code> 的枚举，它有两个成员：<code>Some</code>，它存放了一个类型 <code>T</code> 的值，和不存在任何值的 <code>None</code>。通过 <code>Option&lt;T&gt;</code> 枚举可以表达有一个可能的值的抽象概念，同时因为 <code>Option&lt;T&gt;</code> 是泛型的，无论这个可能的值是什么类型都可以使用这个抽象。</p><p>枚举也可以拥有多个泛型类型。</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">enum Result&lt;T, E&gt; {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    Ok(T),</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    Err(E),</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><code>Result</code> 枚举有两个泛型类型，<code>T</code> 和 <code>E</code>。<code>Result</code> 有两个成员：<code>Ok</code>，它存放一个类型 <code>T</code> 的值，而 <code>Err</code> 则存放一个类型 <code>E</code> 的值。这个定义使得 <code>Result</code> 枚举能很方便的表达任何可能成功（返回 <code>T</code> 类型的值）也可能失败（返回 <code>E</code> 类型的值）的操作。</p><p>当你意识到代码中定义了多个结构体或枚举，它们不一样的地方只是其中的值的类型的时候，不妨通过泛型类型来避免重复。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="方法中的泛型">方法中的泛型<a href="#方法中的泛型" class="hash-link" aria-label="方法中的泛型的直接链接" title="方法中的泛型的直接链接">​</a></h3><p>在为结构体和枚举实现方法时，一样也可以用泛型。示例 10-9 中展示了示例 10-6 中定义的结构体 <code>Point&lt;T&gt;</code>，和在其上实现的名为 <code>x</code> 的方法。</p><p>文件名: src/main.rs</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">struct Point&lt;T&gt; {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    x: T,</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    y: T,</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">impl&lt;T&gt; Point&lt;T&gt; {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    fn x(&amp;self) -&gt; &amp;T {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        &amp;self.x</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let p = Point {x: 5, y: 10, };</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    println!(&quot;p.x = {}&quot;, p.x());</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h5 class="anchor anchorWithStickyNavbar_LWe7" id="示例-10-9在-pointt-结构体上实现方法-x它返回-t-类型的字段-x-的引用">示例 10-9：在 <code>Point&lt;T&gt;</code> 结构体上实现方法 <code>x</code>，它返回 <code>T</code> 类型的字段 <code>x</code> 的引用<a href="#示例-10-9在-pointt-结构体上实现方法-x它返回-t-类型的字段-x-的引用" class="hash-link" aria-label="示例-10-9在-pointt-结构体上实现方法-x它返回-t-类型的字段-x-的引用的直接链接" title="示例-10-9在-pointt-结构体上实现方法-x它返回-t-类型的字段-x-的引用的直接链接">​</a></h5><p>这里在 <code>Point&lt;T&gt;</code> 上定义了一个叫做 <code>x</code> 的方法来返回字段 <code>x</code> 中数据的引用：</p><p>注意必须在 <code>impl</code> 后面声明 <code>T</code>，这样就可以在 <code>Point&lt;T&gt;</code> 上实现的方法中使用它了。在 <code>impl</code> 之后声明泛型 <code>T</code> ，这样 Rust 就知道 <code>Point</code> 的尖括号中的类型是泛型而不是具体类型。</p><p>例如，可以选择为 <code>Point&lt;f32&gt;</code> 实例实现方法，而不是为泛型 <code>Point</code> 实例。示例 10-10 展示了一个没有在 <code>impl</code> 之后（的尖括号）声明泛型的例子，这里使用了一个具体类型，<code>f32</code>：</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">impl Point&lt;f32&gt; {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    fn distance_from_origin(&amp;self) -&gt; f32 {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        ((self.x).powi(2) + (self.y).powi(2)).sqrt()</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h5 class="anchor anchorWithStickyNavbar_LWe7" id="示例-10-10构建一个只用于拥有泛型参数-t-的结构体的具体类型的-impl-块">示例 10-10：构建一个只用于拥有泛型参数 <code>T</code> 的结构体的具体类型的 <code>impl</code> 块<a href="#示例-10-10构建一个只用于拥有泛型参数-t-的结构体的具体类型的-impl-块" class="hash-link" aria-label="示例-10-10构建一个只用于拥有泛型参数-t-的结构体的具体类型的-impl-块的直接链接" title="示例-10-10构建一个只用于拥有泛型参数-t-的结构体的具体类型的-impl-块的直接链接">​</a></h5><p>这段代码意味着 <code>Point&lt;f32&gt;</code> 类型会有一个方法 <code>distance_from_origin</code>，而其他 <code>T</code> 不是 <code>f32</code> 类型的 <code>Point&lt;T&gt;</code> 实例则没有定义此方法。这个方法计算点实例与坐标 <code>(0.0, 0.0)</code> 之间的距离，并使用了只能用于浮点型的数学运算符。</p><p>结构体定义中的泛型类型参数并不总是与结构体方法签名中使用的泛型是同一类型。示例 10-11 中在示例 10-8 中的结构体 <code>Point&lt;T, U&gt;</code> 上定义了一个方法 <code>mixup</code>。这个方法获取另一个 <code>Point</code> 作为参数，而它可能与调用 <code>mixup</code> 的 <code>self</code> 是不同的 <code>Point</code> 类型。这个方法用 <code>self</code> 的 <code>Point</code> 类型的 <code>x</code> 值（类型 <code>T</code>）和参数的 <code>Point</code> 类型的 <code>y</code> 值（类型 <code>W</code>）来创建一个新 <code>Point</code> 类型的实例：</p><p>文件名: src/main.rs</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">struct Point&lt;T, U&gt; {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    x: T,</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    y: U,</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">impl&lt;T, U&gt; Point&lt;T, U&gt; {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    fn mixup&lt;V, W&gt;(self, other: Point&lt;V, W&gt;) -&gt; Point&lt;T, W&gt; {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        Point {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            x: self.x,</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            y: other.y,</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let p1 = Point { x: 5, y: 10.4 };</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let p2 = Point { x: &quot;Hello&quot;, y: &#x27;c&#x27; };</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let p3 = p1.mixup(p2);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    println!(&quot;p3.x = {}, p3.y = {}&quot;, p3.x, p3.y);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h5 class="anchor anchorWithStickyNavbar_LWe7" id="示例-10-11方法使用了与结构体定义中不同类型的泛型">示例 10-11：方法使用了与结构体定义中不同类型的泛型<a href="#示例-10-11方法使用了与结构体定义中不同类型的泛型" class="hash-link" aria-label="示例 10-11：方法使用了与结构体定义中不同类型的泛型的直接链接" title="示例 10-11：方法使用了与结构体定义中不同类型的泛型的直接链接">​</a></h5><p>在 <code>main</code> 函数中，定义了一个有 <code>i32</code> 类型的 <code>x</code>（其值为 <code>5</code>）和 <code>f64</code> 的 <code>y</code>（其值为 <code>10.4</code>）的 <code>Point</code>。<code>p2</code> 则是一个有着字符串 <code>slice</code> 类型的 <code>x</code>（其值为 <code>&quot;Hello&quot;</code>）和 <code>char</code> 类型的 <code>y</code>（其值为 <code>c</code>）的 <code>Point</code>。在 <code>p1</code> 上以 <code>p2</code> 作为参数调用 <code>mixup</code> 会返回一个 <code>p3</code>，它会有一个 <code>i32</code> 类型的 <code>x</code>，因为 <code>x</code> 来自 <code>p1</code>，并拥有一个 <code>char</code> 类型的 <code>y</code>，因为 <code>y</code> 来自 <code>p2</code>。<code>println!</code> 会打印出 <code>p3.x = 5</code>, <code>p3.y = c</code>。</p><p>这个例子的目的是展示一些泛型通过 <code>impl</code> 声明而另一些通过方法定义声明的情况。这里泛型参数 <code>T</code> 和 <code>U</code> 声明于 <code>impl</code> 之后，因为他们与结构体定义相对应。而泛型参数 <code>V</code> 和 <code>W</code> 声明于 <code>fn mixup</code> 之后，因为他们只是相对于方法本身的。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="泛型代码的性能">泛型代码的性能<a href="#泛型代码的性能" class="hash-link" aria-label="泛型代码的性能的直接链接" title="泛型代码的性能的直接链接">​</a></h3><p>在阅读本部分内容的同时，你可能会好奇使用泛型类型参数是否会有运行时消耗。好消息是：Rust 实现了泛型，使得使用泛型类型参数的代码相比使用具体类型并没有任何速度上的损失。</p><p>Rust 通过在编译时进行泛型代码的 <strong>单态化<!-- -->*</strong>（monomorphization）<!-- -->*<!-- -->来保证效率。单态化是一个通过填充编译时使用的具体类型，将通用代码转换为特定代码的过程。</p><p>编译器所做的工作正好与示例 10-5 中我们创建泛型函数的步骤相反。编译器寻找所有泛型代码被调用的位置并使用泛型代码针对具体类型生成代码。</p><p>让我们看看一个使用标准库中 Option 枚举的例子：</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">let integer = Some(5);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">let float = Some(5.0);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>当 Rust 编译这些代码的时候，它会进行单态化。编译器会读取传递给 <code>Option&lt;T&gt;</code> 的值并发现有两种 <code>Option&lt;T&gt;</code>：一个对应 <code>i32</code> 另一个对应 <code>f64</code>。为此，它会将泛型定义 <code>Option&lt;T&gt;</code> 展开为 <code>Option_i32</code> 和 <code>Option_f64</code>，接着将泛型定义替换为这两个具体的定义。</p><p>编译器生成的单态化版本的代码看起来像这样，并包含将泛型 <code>Option&lt;T&gt;</code> 替换为编译器创建的具体定义后的用例代码：</p><p>文件名: src/main.rs</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">enum Option_i32 {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    Some(i32),</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    None,</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">enum Option_f64 {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    Some(f64),</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    None,</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let integer = Option_i32::Some(5);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let float = Option_f64::Some(5.0);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>我们可以使用泛型来编写不重复的代码，而 Rust 将会为每一个实例编译其特定类型的代码。这意味着在使用泛型时没有运行时开销；当代码运行，它的执行效率就跟好像手写每个具体定义的重复代码一样。这个单态化过程正是 Rust 泛型在运行时极其高效的原因。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="trait-定义共享的行为">trait: 定义共享的行为<a href="#trait-定义共享的行为" class="hash-link" aria-label="trait: 定义共享的行为的直接链接" title="trait: 定义共享的行为的直接链接">​</a></h2><p><em>trait</em> 告诉 Rust 编译器某个特定类型拥有可能与其他类型共享的功能。可以通过 trait 以一种抽象的方式定义共享的行为。可以使用 trait bounds 指定泛型是任何拥有特定行为的类型。</p><div class="theme-admonition theme-admonition-caution alert alert--warning admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"></path></svg></span>警告</div><div class="admonitionContent_S0QG"><p>trait 类似于其他语言中常被称为 接口（interfaces）的功能，虽然有一些不同。</p></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="定义-trait">定义 trait<a href="#定义-trait" class="hash-link" aria-label="定义 trait的直接链接" title="定义 trait的直接链接">​</a></h3><p>一个类型的行为由其可供调用的方法构成。如果可以对不同类型调用相同的方法的话，这些类型就可以共享相同的行为了。trait 定义是一种将方法签名组合起来的方法，目的是定义一个实现某些目的所必需的行为的集合。</p><p>例如，这里有多个存放了不同类型和属性文本的结构体：结构体 <code>NewsArticle</code> 用于存放发生于世界各地的新闻故事，而结构体 <code>Tweet</code> 最多只能存放 <code>280</code> 个字符的内容，以及像是否转推或是否是对推友的回复这样的元数据。</p><p>我们想要创建一个多媒体聚合库用来显示可能储存在 <code>NewsArticle</code> 或 <code>Tweet</code> 实例中的数据的总结。每一个结构体都需要的行为是他们是能够被总结的，这样的话就可以调用实例的 <code>summarize</code> 方法来请求总结。示例 10-12 中展示了一个表现这个概念的 <code>Summary</code> trait 的定义：</p><p>文件名: src/lib.rs</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">pub trait Summary {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    fn summarize(&amp;self) -&gt; String;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h5 class="anchor anchorWithStickyNavbar_LWe7" id="示例-10-12summary-trait-定义它包含由-summarize-方法提供的行为">示例 10-12：<code>Summary</code> trait 定义，它包含由 <code>summarize</code> 方法提供的行为<a href="#示例-10-12summary-trait-定义它包含由-summarize-方法提供的行为" class="hash-link" aria-label="示例-10-12summary-trait-定义它包含由-summarize-方法提供的行为的直接链接" title="示例-10-12summary-trait-定义它包含由-summarize-方法提供的行为的直接链接">​</a></h5><p>这里使用 <code>trait</code> 关键字来声明一个 trait，后面是 trait 的名字，在这个例子中是 <code>Summary</code>。在大括号中声明描述实现这个 trait 的类型所需要的行为的方法签名，在这个例子中是 <code>fn summarize(&amp;self) -&gt; String</code>。</p><p>在方法签名后跟分号，而不是在大括号中提供其实现。接着每一个实现这个 trait 的类型都需要提供其自定义行为的方法体，编译器也会确保任何实现 <code>Summary</code> trait 的类型都拥有与这个签名的定义完全一致的 <code>summarize</code> 方法。</p><p>trait 体中可以有多个方法：一行一个方法签名且都以分号结尾。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="为类型实现-trait">为类型实现 trait<a href="#为类型实现-trait" class="hash-link" aria-label="为类型实现 trait的直接链接" title="为类型实现 trait的直接链接">​</a></h3><p>现在我们定义了 <code>Summary</code> trait，接着就可以在多媒体聚合库中需要拥有这个行为的类型上实现它了。示例 10-13 中展示了 <code>NewsArticle</code> 结构体上 <code>Summary</code> trait 的一个实现，它使用标题、作者和创建的位置作为 <code>summarize</code> 的返回值。对于 <code>Tweet</code> 结构体，我们选择将 <code>summarize</code> 定义为用户名后跟推文的全部文本作为返回值，并假设推文内容已经被限制为 <code>280</code> 字符以内。</p><p>文件名: src/lib.rs</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">pub trait Summary {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    fn summarize(&amp;self) -&gt; String;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">pub struct NewsArticle {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    pub headline: String,</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    pub author: String,</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    pub location: String,</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    pub content: String,</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">impl Summary for NewsArticle {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    fn summarize(&amp;self) -&gt; String {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        format!(&quot;{}, by {} ({})&quot;, self.headline, self.author, self.location)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">pub struct Tweet {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    pub username: String,</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    pub content: String,</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    pub reply: bool,</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    pub retweet: bool,</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">impl Summary for Tweet {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    fn summarize(&amp;self) -&gt; String {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        format!(&quot;{}: {}&quot;, self.username, self.content)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h5 class="anchor anchorWithStickyNavbar_LWe7" id="示例-10-13在-newsarticle-和-tweet-类型上实现-summary-trait">示例 10-13：在 <code>NewsArticle</code> 和 <code>Tweet</code> 类型上实现 <code>Summary</code> trait<a href="#示例-10-13在-newsarticle-和-tweet-类型上实现-summary-trait" class="hash-link" aria-label="示例-10-13在-newsarticle-和-tweet-类型上实现-summary-trait的直接链接" title="示例-10-13在-newsarticle-和-tweet-类型上实现-summary-trait的直接链接">​</a></h5><p>在类型上实现 trait 类似于实现与 trait 无关的方法。区别在于 <code>impl</code> 关键字之后，我们提供需要实现 trait 的名称，接着是 <code>for</code> 和需要实现 trait 的类型的名称。在 <code>impl</code> 块中，使用 trait 定义中的方法签名，不过不再后跟分号，而是需要在大括号中编写函数体来为特定类型实现 trait 方法所拥有的行为。</p><p>一旦实现了 trait，我们就可以用与 <code>NewsArticle</code> 和 <code>Tweet</code> 实例的非 <code>trait</code> 方法一样的方式调用 trait 方法了：</p><p>文件名: src/main.rs</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">use aggregator::{Summary, Tweet};</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let tweet = Tweet {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        username: String::from(&quot;hero_ebooks&quot;),</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        content: String::from(&quot;of course, as you probably already know, people&quot;),</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        reply: false,</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        retweet: false,</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    println!(&quot;1 new tweet: {}&quot;, tweet.summarize());</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这会打印出 <code>1 new tweet: horse_ebooks: of course, as you probably already know, people</code>。</p><p>注意因为示例 10-13 中我们在相同的 <code>lib.rs</code> 里定义了 <code>Summary</code> trait 和 <code>NewsArticle</code> 与 <code>Tweet</code> 类型，所以他们是位于同一作用域的。如果这个 <code>lib.rs</code> 是对应 <code>aggregator</code> crate 的，而别人想要利用我们 crate 的功能为其自己的库作用域中的结构体实现 <code>Summary</code> trait。首先他们需要将 <code>trait</code> 引入作用域。这可以通过指定 <code>use aggregator::Summary;</code> 实现，这样就可以为其类型实现 <code>Summary</code> trait 了。<code>Summary</code> 还必须是公有 trait 使得其他 crate 可以实现它，这也是为什么实例 10-12 中将 pub 置于 trait 之前。</p><p>实现 trait 时需要注意的一个限制是，只有当 trait 或者要实现 trait 的类型位于 crate 的本地作用域时，才能为该类型实现 trait。例如，可以为 <code>aggregator</code> crate 的自定义类型 <code>Tweet</code> 实现如标准库中的 <code>Display</code> trait，这是因为 <code>Tweet</code> 类型位于 <code>aggregator</code> crate 本地的作用域中。类似地，也可以在 <code>aggregator</code> crate 中为 <code>Vec&lt;T&gt;</code> 实现 <code>Summary</code>，这是因为 <code>Summary</code> trait 位于 <code>aggregator</code> crate 本地作用域中。</p><p>但是不能为外部类型实现外部 trait。例如，不能在 <code>aggregator</code> crate 中为 <code>Vec&lt;T&gt;</code> 实现 <code>Display</code> trait。这是因为 <code>Display</code> 和 <code>Vec&lt;T&gt;</code> 都定义于标准库中，它们并不位于 <code>aggregator</code> crate 本地作用域中。这个限制是被称为 <strong>相干性</strong><em>（coherence）</em> 的程序属性的一部分，或者更具体的说是 <strong>孤儿规则</strong><em>（orphan rule）</em>，其得名于不存在父类型。这条规则确保了其他人编写的代码不会破坏你代码，反之亦然。没有这条规则的话，两个 crate 可以分别对相同类型实现相同的 trait，而 Rust 将无从得知应该使用哪一个实现。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="默认实现">默认实现<a href="#默认实现" class="hash-link" aria-label="默认实现的直接链接" title="默认实现的直接链接">​</a></h3><p>有时为 trait 中的某些或全部方法提供默认的行为，而不是在每个类型的每个实现中都定义自己的行为是很有用的。这样当为某个特定类型实现 trait 时，可以选择保留或重载每个方法的默认行为。</p><p>示例 10-14 中展示了如何为 <code>Summary</code> trait 的 <code>summarize</code> 方法指定一个默认的字符串值，而不是像示例 10-12 中那样只是定义方法签名：</p><p>文件名: src/lib.rs</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">pub trait Summary {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    fn summarize(&amp;self) -&gt; String {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        String::from(&quot;Read more...&quot;)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h5 class="anchor anchorWithStickyNavbar_LWe7" id="示例-10-14summary-trait-的定义带有一个-summarize-方法的默认实现">示例 10-14：<code>Summary</code> trait 的定义，带有一个 <code>summarize</code> 方法的默认实现<a href="#示例-10-14summary-trait-的定义带有一个-summarize-方法的默认实现" class="hash-link" aria-label="示例-10-14summary-trait-的定义带有一个-summarize-方法的默认实现的直接链接" title="示例-10-14summary-trait-的定义带有一个-summarize-方法的默认实现的直接链接">​</a></h5><p>如果想要对 <code>NewsArticle</code> 实例使用这个默认实现，而不是定义一个自己的实现，则可以通过 <code>impl Summary for NewsArticle {}</code> 指定一个空的 <code>impl</code> 块。</p><p>虽然我们不再直接为 <code>NewsArticle</code> 定义 <code>summarize</code> 方法了，但是我们提供了一个默认实现并且指定 <code>NewsArticle</code> 实现 <code>Summary</code> trait。因此，我们仍然可以对 <code>NewsArticle</code> 实例调用 <code>summarize</code> 方法，如下所示：</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">let article = NewsArticle {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    headline: String::from(&quot;Penguins win the Stanley Cup Championship!&quot;),</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    location: String::from(&quot;Pittsburgh, PA, USA&quot;),</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    author: String::from(&quot;Iceburgh&quot;),</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    content: String::from(&quot;The Pittsburgh Penguins once again are the best</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    hockey team in the NHL.&quot;),</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">};</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">println!(&quot;New article available! {}&quot;, article.summarize());</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这段代码会打印 <code>New article available! (Read more...)</code>。</p><p>为 <code>summarize</code> 创建默认实现并不要求对示例 10-13 中 <code>Tweet</code> 上的 <code>Summary</code> 实现做任何改变。其原因是重载一个默认实现的语法与实现没有默认实现的 trait 方法的语法一样。</p><p>默认实现允许调用相同 trait 中的其他方法，哪怕这些方法没有默认实现。如此，trait 可以提供很多有用的功能而只需要实现指定一小部分内容。例如，我们可以定义 <code>Summary</code> trait，使其具有一个需要实现的 <code>summarize_author</code> 方法，然后定义一个 <code>summarize</code> 方法，此方法的默认实现调用 <code>summarize_author</code> 方法：</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">pub trait Summary {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    fn summarize_author(&amp;self) -&gt; String;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    fn summarize(&amp;self) -&gt; String {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">      format!(&quot;Read more from {} ...&quot;, self.summarize_author())</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>为了使用这个版本的 <code>Summary</code>，只需在实现 trait 时定义 <code>summarize_author</code> 即可：</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">impl Summary for Tweet {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    fn summarize_author(&amp;self) -&gt; String {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        format!(&quot;@{}&quot;, self.username)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>一旦定义了 <code>summarize_author</code>，我们就可以对 <code>Tweet</code> 结构体的实例调用 <code>summarize</code> 了，而 <code>summarize</code> 的默认实现会调用我们提供的 <code>summarize_author</code> 定义。因为实现了 <code>summarize_author</code>，<code>Summary</code> trait 就提供了 <code>summarize</code> 方法的功能，且无需编写更多的代码。</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">let tweet = Tweet {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    username: String::from(&quot;horse_ebooks&quot;),</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    content: String::from(&quot;of course, as you probably already know, people&quot;),</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    reply: false,</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    retweet: false,</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">};</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">println!(&quot;1 new tweet: {}&quot;, tweet.summarize());</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这会打印出 <code>1 new tweet: (Read more from @horse_ebooks...)</code>。</p><p>请注意，无法从相同方法的重载实现中调用默认方法。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="trait-作为参数">trait 作为参数<a href="#trait-作为参数" class="hash-link" aria-label="trait 作为参数的直接链接" title="trait 作为参数的直接链接">​</a></h3><p>知道了如何定义 trait 和在类型上实现这些 trait 之后，我们可以探索一下如何使用 trait 来接受多种不同类型的参数。</p><p>例如在示例 10-13 中为 <code>NewsArticle</code> 和 <code>Tweet</code> 类型实现了 <code>Summary</code> trait。我们可以定义一个函数 <code>notify</code> 来调用其参数 item 上的 summarize 方法，该参数是实现了 Summary trait 的某种类型。为此可以使用 impl Trait 语法，像这样：</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">pub fn notify(item: impl Summary) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    println!(&quot;Breaking news! {}&quot;, item.summarize())</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>对于 <code>item</code> 参数，我们指定了 <code>impl</code> 关键字和 trait 名称，而不是具体的类型。该参数支持任何实现了指定 trait 的类型。在 <code>notify</code> 函数体中，可以调用任何来自 <code>Summary</code> trait 的方法，比如 <code>summarize</code>。我们可以传递任何 <code>NewsArticle</code> 或 <code>Tweet</code> 的实例来调用 <code>notify</code>。任何用其它如 <code>String</code> 或 <code>i32</code> 的类型调用该函数的代码都不能编译，因为它们没有实现 <code>Summary</code>。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="trait-bound-语法">Trait Bound 语法<a href="#trait-bound-语法" class="hash-link" aria-label="Trait Bound 语法的直接链接" title="Trait Bound 语法的直接链接">​</a></h4><p><code>impl Trait</code> 语法适用于直观的例子，它实际上是一种较长形式语法的语法糖。我们称为 <em>trait bound</em>，它看起来像：</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">pub fn notify&lt;T: Summary&gt;(item: T) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    println!(&quot;Breaking news! {}&quot;, item.summarize())</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这与之前的例子相同，不过稍微冗长了一些。<code>trait bound</code> 与泛型参数声明在一起，位于尖括号中的冒号后面。</p><p><code>impl Trait</code> 很方便，适用于短小的例子。<code>trait bound</code> 则适用于更复杂的场景。例如，可以获取两个实现了 <code>Summary</code> 的参数。使用 <code>impl Trait</code> 的语法看起来像这样：</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">pub fn notify(item1: impl Summary, item2: impl Summary) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这适用于 <code>item1</code> 和 <code>item2</code> 允许是不同类型的情况（只要它们都实现了 <code>Summary</code>）。不过如果你希望强制它们都是相同类型呢？这只有在使用 trait bound 时才有可能：</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">pub fn notify&lt;T: Summary&gt;(item1: T, item2: T) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>泛型 <code>T</code> 被指定为 <code>item1</code> 和 <code>item2</code> 的参数限制，如此传递给参数 <code>item1</code> 和 <code>item2</code> 值的具体类型必须一致。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="通过--指定多个-trait-bound">通过 + 指定多个 trait bound<a href="#通过--指定多个-trait-bound" class="hash-link" aria-label="通过 + 指定多个 trait bound的直接链接" title="通过 + 指定多个 trait bound的直接链接">​</a></h4><p>如果 <code>notify</code> 需要显示 <code>item</code> 的格式化形式，同时也要使用 <code>summarize</code> 方法，那么 <code>item</code> 就需要同时实现两个不同的 trait：<code>Display</code> 和 <code>Summary</code>。这可以通过 <code>+</code> 语法实现：</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">pub fn notify(item: impl Display + Summary) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    // ..</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><code>+</code> 语法也适用于泛型的 trait bound：</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">pub fn notify&lt;T: Display + Summary&gt;(item: T) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="通过-where-简化-trait-bound">通过 where 简化 trait bound<a href="#通过-where-简化-trait-bound" class="hash-link" aria-label="通过 where 简化 trait bound的直接链接" title="通过 where 简化 trait bound的直接链接">​</a></h4><p>然而，使用过多的 trait bound 也有缺点。每个泛型有其自己的 trait bound，所以有多个泛型参数的函数在名称和参数列表之间会有很长的 trait bound 信息，这使得函数签名难以阅读。为此，Rust 有另一个在函数签名之后的 <code>where</code> 从句中指定 trait bound 的语法。所以除了这么写：</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">pub fn notify&lt;T: Display + Summary, U: Clone + Debug&gt;(t: T, u: U) -&gt; i32 {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>还可以像这样使用 <code>where</code> 从句：</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">pub fn notify&lt;T, U&gt;(t: T, u: u)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">where</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    T: Display + Summary,</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    U: Clone + Debug,</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">{</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这个函数签名就显得不那么杂乱，函数名、参数列表和返回值类型都离得很近，看起来跟没有那么多 trait bounds 的函数很像。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="返回实现-trait-的类型">返回实现 trait 的类型<a href="#返回实现-trait-的类型" class="hash-link" aria-label="返回实现 trait 的类型的直接链接" title="返回实现 trait 的类型的直接链接">​</a></h3><p>也可以在返回值中使用 <code>impl Trait</code> 语法，来返回实现了某个 trait 的类型：</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn returns_summarizable() -&gt; impl Summary {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    Tweet {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        username: String::from(&quot;heros_ebooks&quot;),</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        content: String::from(&quot;of course, as you probably already know, people.&quot;),</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        reply: false,</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        retweet: false,</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>通过使用 <code>impl Summary</code> 作为返回值类型，我们指定了 <code>returns_summarizable</code> 函数返回某个实现了 <code>Summary</code> trait 的类型，但是不确定其具体的类型。在这个例子中 <code>returns_summarizable</code> 返回了一个 <code>Tweet</code>，不过调用方并不知情。</p><p>返回一个只是指定了需要实现的 trait 的类型的能力在闭包和迭代器场景十分的有用。闭包和迭代器创建只有编译器知道的类型，或者是非常非常长的类型。<code>impl Trait</code> 允许你简单的指定函数返回一个 Iterator 而无需写出实际的冗长的类型。</p><p>不过这只适用于返回单一类型的情况。例如，这段代码的返回值类型指定为返回 <code>impl Summary</code>，但是返回了 <code>NewsArticle</code> 或 <code>Tweet</code> 就行不通：</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn returns_summarizable(switch: bool) -&gt; impl Summary {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    if switch {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        NewsArticle {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            headline: String::from(&quot;Penguins win the Stanley Cup Championship!&quot;),</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            location: String::from(&quot;Pittsburgh, PA, USA&quot;),</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            author: String::from(&quot;Iceburgh&quot;),</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            content: String::from(&quot;The Pittsburgh Penguins once again are the best</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            hockey team in the NHL.&quot;),</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        Tweet {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            username: String::from(&quot;horse_ebooks&quot;),</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            content: String::from(&quot;of course, as you probably already know, people&quot;),</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            reply: false,</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            retweet: false,</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这里尝试返回 <code>NewsArticle</code> 或 <code>Tweet</code>。这不能编译，因为 <code>impl Trait</code> 工作方式的限制。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="使用-trait-bounds-来修复-largest-函数">使用 trait bounds 来修复 largest 函数<a href="#使用-trait-bounds-来修复-largest-函数" class="hash-link" aria-label="使用 trait bounds 来修复 largest 函数的直接链接" title="使用 trait bounds 来修复 largest 函数的直接链接">​</a></h3><p>现在你知道了如何使用泛型参数 trait bound 来指定所需的行为。让我们回到实例 10-5 修复使用泛型类型参数的 <code>largest</code> 函数定义！回顾一下，最后尝试编译代码时出现的错误是：</p><div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">PS E:\github\rust-projects\generate_type&gt; cargo run</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">   Compiling generate_type v0.1.0 (E:\github\rust-projects\generate_type)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">error</span><span class="token url-reference url punctuation" style="color:rgb(248, 248, 242)">[</span><span class="token url-reference url variable" style="color:rgb(189, 147, 249);font-style:italic">E0369</span><span class="token url-reference url punctuation" style="color:rgb(248, 248, 242)">]</span><span class="token url-reference url punctuation" style="color:rgb(248, 248, 242)">:</span><span class="token url-reference url"> binary</span><span class="token plain"> operation </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`&gt;`</span><span class="token plain"> cannot be applied to type </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`T`</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"> --&gt; src\main.rs:5:17</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">5 |         if item &gt; largest {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |            ---- ^ ------- T</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |            |</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |            T</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">help: consider restricting type parameter </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`T`</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">1 | fn largest</span><span class="token tag punctuation" style="color:rgb(248, 248, 242)">&lt;</span><span class="token tag namespace" style="color:rgb(255, 121, 198)">T:</span><span class="token tag" style="color:rgb(255, 121, 198)"> </span><span class="token tag attr-name namespace" style="color:rgb(241, 250, 140)">std:</span><span class="token tag attr-name" style="color:rgb(241, 250, 140)">:cmp::PartialOrd</span><span class="token tag punctuation" style="color:rgb(248, 248, 242)">&gt;</span><span class="token plain">(list: &amp;[T]) -&gt; T {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |             ++++++++++++++++++++++</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">For more information about this error, try </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`rustc --explain E0369`</span><span class="token plain">.</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">error: could not compile </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`generate_type`</span><span class="token plain"> (bin &quot;generate_type&quot;) due to previous error</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在 <code>largest</code> 函数体中我们想要使用大于运算符（<code>&gt;</code>）比较两个 <code>T</code> 类型的值。这个运算符被定义为标准库中 <code>trait std::cmp::PartialOrd</code> 的一个默认方法。所以需要在 <code>T</code> 的 trait bound 中指定 <code>PartialOrd</code>，这样 <code>largest</code> 函数可以用于任何可以比较大小的类型的 <code>slice</code>。因为 <code>PartialOrd</code> 位于 <code>prelude</code> 中所以并不需要手动将其引入作用域。将 <code>largest</code> 的签名修改为如下：</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn largest&lt;T: PartialOrd&gt;(list: &amp;[T]) -&gt; T {</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>但是如果编译代码的话，会出现一些不同的错误：</p><div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">PS E:\github\rust-projects\generate_type&gt; cargo run</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">   Compiling generate_type v0.1.0 (E:\github\rust-projects\generate_type)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">error</span><span class="token url-reference url punctuation" style="color:rgb(248, 248, 242)">[</span><span class="token url-reference url variable" style="color:rgb(189, 147, 249);font-style:italic">E0508</span><span class="token url-reference url punctuation" style="color:rgb(248, 248, 242)">]</span><span class="token url-reference url punctuation" style="color:rgb(248, 248, 242)">:</span><span class="token url-reference url"> cannot</span><span class="token plain"> move out of type </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`[T]`</span><span class="token plain">, a non-copy slice</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"> --&gt; src\main.rs:2:23</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">2 |     let mut largest = list[0];</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |                       ^^^^^^^</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |                       |</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |                       cannot move out of here</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |                       move occurs because </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`list[_]`</span><span class="token plain"> has type </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`T`</span><span class="token plain">, which does not implement the </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`Copy`</span><span class="token plain"> trait</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">help: consider borrowing here</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">2 |     let mut largest = &amp;list[0];</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |                       +</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">error</span><span class="token url-reference url punctuation" style="color:rgb(248, 248, 242)">[</span><span class="token url-reference url variable" style="color:rgb(189, 147, 249);font-style:italic">E0507</span><span class="token url-reference url punctuation" style="color:rgb(248, 248, 242)">]</span><span class="token url-reference url punctuation" style="color:rgb(248, 248, 242)">:</span><span class="token url-reference url"> cannot</span><span class="token plain"> move out of a shared reference</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"> --&gt; src\main.rs:4:18</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">4 |     for &amp;item in list {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |          ----    ^^^^</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |          |</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |          data moved here</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |          move occurs because </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`item`</span><span class="token plain"> has type </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`T`</span><span class="token plain">, which does not implement the </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`Copy`</span><span class="token plain"> trait</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">help: consider removing the borrow</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">4 -     for &amp;item in list {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">4 +     for item in list {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">Some errors have detailed explanations: E0507, E0508.</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">For more information about an error, try </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`rustc --explain E0507`</span><span class="token plain">.</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">error: could not compile </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`generate_type`</span><span class="token plain"> (bin &quot;generate_type&quot;) due to 2 previous errors</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>错误的核心是 <code>cannot move out of type [T], a non-copy slice</code>，对于非泛型版本的 <code>largest</code> 函数，我们只尝试了寻找最大的 <code>i32</code> 和 <code>char</code>。像 <code>i32</code> 和 <code>char</code> 这样的类型是已知大小的并可以储存在栈上，所以他们实现了 <code>Copy</code> trait。当我们将 <code>largest</code> 函数改成使用泛型后，现在 <code>list</code> 参数的类型就有可能是没有实现 <code>Copy</code> trait 的。这意味着我们可能不能将 <code>list[0]</code> 的值移动到 <code>largest</code> 变量中，这导致了上面的错误。</p><p>为了只对实现了 <code>Copy</code> 的类型调用这些代码，可以在 <code>T</code> 的 trait bounds 中增加 <code>Copy</code>！示例 10-15 中展示了一个可以编译的泛型版本的 <code>largest</code> 函数的完整代码，只要传递给 <code>largest</code> 的 <code>slice</code> 值的类型实现了 <code>PartialOrd</code> 和 <code>Copy</code> 这两个 trait，例如 <code>i32</code> 和 <code>char</code>：</p><p>文件名: src/main.rs</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn largest&lt;T: PartialOrd + Copy&gt;(list: &amp;[T]) -&gt; T {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let mut largest = list[0];</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    for &amp;item in list {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        if item &gt; largest {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            largest = item;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    largest</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let number_list = vec![34, 50, 25, 100, 65];</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let result = largest(&amp;number_list);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    println!(&quot;The largest number is {}&quot;, result);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let char_list = vec![&#x27;y&#x27;, &#x27;m&#x27;, &#x27;a&#x27;, &#x27;q&#x27;];</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let result = largest(&amp;char_list);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    println!(&quot;The largest char is {}&quot;, result);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h5 class="anchor anchorWithStickyNavbar_LWe7" id="示例-10-15一个可以用于任何实现了-partialord-和-copy-trait-的泛型的-largest-函数">示例 10-15：一个可以用于任何实现了 <code>PartialOrd</code> 和 <code>Copy</code> trait 的泛型的 <code>largest</code> 函数<a href="#示例-10-15一个可以用于任何实现了-partialord-和-copy-trait-的泛型的-largest-函数" class="hash-link" aria-label="示例-10-15一个可以用于任何实现了-partialord-和-copy-trait-的泛型的-largest-函数的直接链接" title="示例-10-15一个可以用于任何实现了-partialord-和-copy-trait-的泛型的-largest-函数的直接链接">​</a></h5><p>如果并不希望限制 <code>largest</code> 函数只能用于实现了 <code>Copy</code> trait 的类型，我们可以在 <code>T</code> 的 trait bounds 中指定 <code>Clone</code> 而不是 <code>Copy</code>。并克隆 <code>slice</code> 的每一个值使得 <code>largest</code> 函数拥有其所有权。使用 <code>clone</code> 函数意味着对于类似 <code>String</code> 这样拥有堆上数据的类型，会潜在的分配更多堆上空间，而堆分配在涉及大量数据时可能会相当缓慢。</p><p>另一种 <code>largest</code> 的实现方式是返回在 <code>slice</code> 中 <code>T</code> 值的引用。如果我们将函数返回值从 <code>T</code> 改为 <code>&amp;T</code> 并改变函数体使其能够返回一个引用，我们将不需要任何 <code>Clone</code> 或 <code>Copy</code> 的 trait bounds 而且也不会有任何的堆分配。尝试自己实现这种替代解决方式吧！</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="使用-trait-bound-有条件地实现方法">使用 trait bound 有条件地实现方法<a href="#使用-trait-bound-有条件地实现方法" class="hash-link" aria-label="使用 trait bound 有条件地实现方法的直接链接" title="使用 trait bound 有条件地实现方法的直接链接">​</a></h3><p>通过使用带有 trait bound 的泛型参数的 <code>impl</code> 块，可以有条件地只为那些实现了特定 trait 的类型实现方法。例如，示例 10-16 中的类型 <code>Pair&lt;T&gt;</code> 总是实现了 <code>new</code> 方法，不过只有那些为 <code>T</code> 类型实现了 <code>PartialOrd</code> trait （来允许比较） 和 <code>Display</code> trait （来启用打印）的 <code>Pair&lt;T&gt;</code> 才会实现 <code>cmp_display</code> 方法：</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">use std::fmt::Display;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">struct Pair&lt;T&gt; {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    x: T,</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    y: T,</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">impl&lt;T&gt; Pair&lt;T&gt; {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    fn new(x: T, y: T) -&gt; Self {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        Self { x, y }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">impl&lt;T: Display + PartialOrd&gt; Pair&lt;T&gt; {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    fn cmp_display(&amp;self) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        if self.x &gt;= self.y {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            println!(&quot;The largest member is x = {}&quot;, self.x);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            println!(&quot;The largest member is x = {}&quot;, self.y);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h5 class="anchor anchorWithStickyNavbar_LWe7" id="示例-10-16根据-trait-bound-在泛型上有条件的实现方法">示例 10-16：根据 trait bound 在泛型上有条件的实现方法<a href="#示例-10-16根据-trait-bound-在泛型上有条件的实现方法" class="hash-link" aria-label="示例 10-16：根据 trait bound 在泛型上有条件的实现方法的直接链接" title="示例 10-16：根据 trait bound 在泛型上有条件的实现方法的直接链接">​</a></h5><p>也可以对任何实现了特定 trait 的类型有条件地实现 trait。对任何满足特定 trait bound 的类型实现 trait 被称为 <em>blanket implementations</em>，他们被广泛的用于 Rust 标准库中。例如，标准库为任何实现了 <code>Display</code> trait 的类型实现了 <code>ToString</code> trait。这个 <code>impl</code> 块看起来像这样：</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">impl&lt;T: Display&gt; ToString for T {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    // ---snip---</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>因为标准库有了这些 <code>blanket implementation</code>，我们可以对任何实现了 <code>Display</code> trait 的类型调用由 <code>ToString</code> 定义的 <code>to_string</code> 方法。例如，可以将整型转换为对应的 <code>String</code> 值，因为整型实现了 <code>Display</code>：</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">let s = 3.to_string();</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>blanket implementation 会出现在 trait 文档的 “Implementors” 部分。</p><p>trait 和 trait bound 让我们使用泛型类型参数来减少重复，并仍然能够向编译器明确指定泛型类型需要拥有哪些行为。因为我们向编译器提供了 trait bound 信息，它就可以检查代码中所用到的具体类型是否提供了正确的行为。在动态类型语言中，如果我们尝试调用一个类型并没有实现的方法，会在运行时出现错误。Rust 将这些错误移动到了编译时，甚至在代码能够运行之前就强迫我们修复错误。另外，我们也无需编写运行时检查行为的代码，因为在编译时就已经检查过了，这样相比其他那些不愿放弃泛型灵活性的语言有更好的性能。</p><p>这里还有一种泛型，我们一直在使用它甚至都没有察觉它的存在，这就是 <strong>生命周期</strong><em>（lifetimes）</em>。不同于其他泛型帮助我们确保类型拥有期望的行为，生命周期则有助于确保引用在我们需要他们的时候一直有效。让我们学习生命周期是如何做到这些的。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="生命周期与引用有效性">生命周期与引用有效性<a href="#生命周期与引用有效性" class="hash-link" aria-label="生命周期与引用有效性的直接链接" title="生命周期与引用有效性的直接链接">​</a></h2><p>Rust 中的每一个引用都有其 <strong>生命周期</strong>（lifetime），也就是引用保持有效的作用域。大部分时候生命周期是隐含并可以推断的，正如大部分时候类型也是可以推断的一样。类似于当因为有多种可能类型的时候必须注明类型，也会出现引用的生命周期以一些不同方式相关联的情况，所以 Rust 需要我们使用泛型生命周期参数来注明他们的关系，这样就能确保运行时实际使用的引用绝对是有效的。</p><p>生命周期的概念从某种程度上说不同于其他语言中类似的工具，毫无疑问这是 Rust 最与众不同的功能。虽然本章不可能涉及到它全部的内容，我们会讲到一些通常你可能会遇到的生命周期语法以便你熟悉这个概念。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="生命周期避免了悬垂引用">生命周期避免了悬垂引用<a href="#生命周期避免了悬垂引用" class="hash-link" aria-label="生命周期避免了悬垂引用的直接链接" title="生命周期避免了悬垂引用的直接链接">​</a></h3><p>生命周期的主要目标是避免悬垂引用，它会导致程序引用了非预期引用的数据。考虑一下示例 10-17 中的程序，它有一个外部作用域和一个内部作用域。</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let r;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        let x = 5;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        r = &amp;x;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    println!(&quot;r: {}&quot;, r);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h5 class="anchor anchorWithStickyNavbar_LWe7" id="示例-10-17尝试使用离开作用域的值的引用">示例 10-17：尝试使用离开作用域的值的引用<a href="#示例-10-17尝试使用离开作用域的值的引用" class="hash-link" aria-label="示例 10-17：尝试使用离开作用域的值的引用的直接链接" title="示例 10-17：尝试使用离开作用域的值的引用的直接链接">​</a></h5><p>外部作用域声明了一个没有初值的变量 <code>r</code>，而内部作用域声明了一个初值为 <code>5</code> 的变量 <code>x</code>。在内部作用域中，我们尝试将 <code>r</code> 的值设置为一个 <code>x</code> 的引用。接着在内部作用域结束后，尝试打印出 <code>r</code> 的值。这段代码不能编译因为 <code>r</code> 引用的值在尝试使用之前就离开了作用域。如下是错误信息：</p><div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">PS E:\github\rust-projects\lifetimes&gt; cargo run</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">   Compiling lifetimes v0.1.0 (E:\github\rust-projects\lifetimes)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">error</span><span class="token url-reference url punctuation" style="color:rgb(248, 248, 242)">[</span><span class="token url-reference url variable" style="color:rgb(189, 147, 249);font-style:italic">E0597</span><span class="token url-reference url punctuation" style="color:rgb(248, 248, 242)">]</span><span class="token url-reference url punctuation" style="color:rgb(248, 248, 242)">:</span><span class="token url-reference url"> `x`</span><span class="token plain"> does not live long enough</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"> --&gt; src\main.rs:6:13</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">5 |         let x = 5;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |             - binding </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`x`</span><span class="token plain"> declared here</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">6 |         r = </span><span class="token entity named-entity">&amp;x;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |             ^^ borrowed value does not live long enough</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">7 |     }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |     - </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`x`</span><span class="token plain"> dropped here while still borrowed</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">8 |</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">9 |     println!(&quot;r: {}&quot;, r);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |                       - borrow later used here</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">For more information about this error, try </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`rustc --explain E0597`</span><span class="token plain">.</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">error: could not compile </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`lifetimes`</span><span class="token plain"> (bin &quot;lifetimes&quot;) due to previous error</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>变量 <code>x</code> 并没有 “存在的足够久”。其原因是 <code>x</code> 在到达第 7 行内部作用域结束时就离开了作用域。不过 <code>r</code> 在外部作用域仍是有效的；作用域越大我们就说它 “存在的越久”。如果 Rust 允许这段代码工作，<code>r</code> 将会引用在 <code>x</code> 离开作用域时被释放的内存，这时尝试对 <code>r</code> 做任何操作都不能正常工作。那么 Rust 是如何决定这段代码是不被允许的呢？这得益于借用检查器。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="借用检查器">借用检查器<a href="#借用检查器" class="hash-link" aria-label="借用检查器的直接链接" title="借用检查器的直接链接">​</a></h4><p>Rust 编译器有一个 <strong>借用检查器</strong><em>（borrow checker）</em>，它比较作用域来确保所有的借用都是有效的。示例 10-18 展示了与示例 10-17 相同的例子，不过带有变量生命周期的注释：</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="函数中的泛型生命周期">函数中的泛型生命周期<a href="#函数中的泛型生命周期" class="hash-link" aria-label="函数中的泛型生命周期的直接链接" title="函数中的泛型生命周期的直接链接">​</a></h3></div><footer class="row docusaurus-mt-lg"><div class="col"><b>标签：</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/my-website/blog/tags/rust">rust</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/my-website/blog/tags/入门">入门</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/my-website/blog/tags/泛型">泛型</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/my-website/blog/tags/trait">trait</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/my-website/blog/tags/生命周期">生命周期</a></li></ul></div></footer></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><meta itemprop="description" content="记录 Rust 学习过程"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/my-website/blog/2023/10/26/rust-package-crate-module">Rust 使用包、Crate和模块管理不断增长的项目</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-10-26T00:00:00.000Z" itemprop="datePublished">2023年10月26日</time> · <!-- -->阅读需 30 分钟</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://github.com/hbche" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://github.com/hbche.png" alt="Hanbin Che" itemprop="image"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/hbche" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Hanbin Che</span></a></div><small class="avatar__subtitle" itemprop="description">Front End Engineer</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><p>当你编写大型程序时，组织你的代码显得尤为重要，因为你想在脑海中通晓整个程序，那几乎是不可能完成的。通过对相关功能进行分组和划分不同功能的代码，你可以清楚在哪里可以找到实现了特定功能的代码，以及在哪里可以改变一个功能的工作方式。</p><p>伴随着项目的增长，你可以通过将代码分解为多个模块和多个文件来组织代码。一个包可以包含多个二进制 crate 项和一个可选的 crate 库。伴随着包的增长，你可以将包中的部分代码提取出来，做成独立的 crate，这些 crate 则作为外部依赖项。本章将会涵盖所有这些概念。对于一个由一系列相互关联的包组合而成的超大型项目，Cargo 提供了 “工作空间” 这一功能。</p><p>除了对功能进行分组以外，封装实现细节可以使你更高级地重用代码：你实现了一个操作后，其他的代码可以通过该代码的公共接口来进行调用，而不需要知道它是如何实现的。你在编写代码时可以定义哪些部分是其他代码可以使用的公共部分，以及哪些部分是你有权更改实现细节的私有部分。这是另一种减少你在脑海中记住项目内容数量的方法。</p><p>这里有一个需要说明的概念 “作用域（scope）”：代码所在的嵌套上下文有一组定义为 “in scope” 的名称。当阅读、编写和编译代码时，开发者和编译器需要知道特定位置的特定名称是否引用了变量、函数、结构体、枚举、模块、常量或者其他有意义的项。你可以创建作用域，以及改变哪些名称在作用域内还是作用域外。同一个作用域内不能拥有两个相同名称的项；可以使用一些工具来解决名称冲突。</p><p>Rust 有许多功能可以让你管理代码的组织，包括哪些内容可以被公开，哪些内容作为私有部分，以及程序每个作用域中的名字。这些功能。这有时被称为 “模块系统（the module system）”，包括：</p><ul><li><strong>包</strong>(<em>Package</em>): Cargo 的一个功能是它允许我们构建、测试和分享 crate。</li><li><strong>Crates</strong>: 一个模块的树形结构，他形成了库或二进制项目。</li><li><strong>模块</strong>(<em>Modules</em>)和 <strong>use</strong>: 允许我们控制作用域和路径的私有性。</li><li><strong>路径</strong>(<em>path</em>): 一个命名例如结构体、函数或模块等项的方式。</li></ul><p>本章将会涵盖所有这些概念，讨论它们如何交互，并说明如何使用它们来管理作用域。到最后，你会对模块系统有深入的了解，并且能够像专业人士一样使用作用域！</p></div><footer class="row docusaurus-mt-lg"><div class="col col--9"><b>标签：</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/my-website/blog/tags/rust">rust</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/my-website/blog/tags/入门">入门</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/my-website/blog/tags/包">包</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/my-website/blog/tags/crate">crate</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/my-website/blog/tags/模块">模块</a></li></ul></div><div class="col text--right col--3"><a aria-label="阅读 Rust 使用包、Crate和模块管理不断增长的项目 的全文" href="/my-website/blog/2023/10/26/rust-package-crate-module"><b>阅读更多</b></a></div></footer></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><meta itemprop="description" content="记录 Rust 学习过程"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/my-website/blog/2023/10/23/rust-collections">Rust 常见集合</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-10-23T00:00:00.000Z" itemprop="datePublished">2023年10月23日</time> · <!-- -->阅读需 30 分钟</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://github.com/hbche" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://github.com/hbche.png" alt="Hanbin Che" itemprop="image"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/hbche" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Hanbin Che</span></a></div><small class="avatar__subtitle" itemprop="description">Front End Engineer</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><p>Rust 标准库中包含一系列被称为 <strong>集合</strong>（collections）的非常有用的数据结构。大部分其他数据类型都代表一个特定的值，不过集合可以包含多个值。不同于内建的数组和元组类型，这些集合指向的数据是储存在堆上的，这意味着数据的数量不必在编译时就已知，并且还可以随着程序的运行增长或缩小。每种集合都有着不同功能和成本，而根据当前情况选择合适的集合，这是一项应当逐渐掌握的技能。接下来我们将详细的了解三个在 Rust 程序中被广泛使用的集合：</p><ul><li>vector 允许我们一个挨着一个地储存一系列数量可变的值</li><li>字符串（string）是字符的集合。我们之前见过 String 类型，不过在本章我们将深入了解。</li><li>哈希 map（hash map）允许我们将值与一个特定的键（key）相关联。这是一个叫做 map 的更通用的数据结构的特定实现。</li></ul><p>对于标准库提供的其他类型的集合，请查看<a href="https://rustwiki.org/zh-CN/std/collections/" target="_blank" rel="noopener noreferrer">文档</a>。</p><p>我们将讨论如何创建和更新 vector、字符串和哈希 map，以及它们有什么特别之处。</p></div><footer class="row docusaurus-mt-lg"><div class="col col--9"><b>标签：</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/my-website/blog/tags/rust">rust</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/my-website/blog/tags/入门">入门</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/my-website/blog/tags/集合">集合</a></li></ul></div><div class="col text--right col--3"><a aria-label="阅读 Rust 常见集合 的全文" href="/my-website/blog/2023/10/23/rust-collections"><b>阅读更多</b></a></div></footer></article><nav class="pagination-nav" aria-label="博文列表分页导航"><a class="pagination-nav__link pagination-nav__link--next" href="/my-website/blog/page/2"><div class="pagination-nav__label">较旧的博文</div></a></nav></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2024 hbche, Inc. Built with <a href="https://www.docusaurus.cn/" target="_blank" rel="noopener noreferrer">Docusaurus</a>.</div></div></div></footer></div>
<script src="/my-website/assets/js/runtime~main.2bef15ca.js"></script>
<script src="/my-website/assets/js/main.384afa70.js"></script>
</body>
</html>