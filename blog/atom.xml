<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://hbche.github.io/my-website/blog</id>
    <title>小车的小书屋 Blog</title>
    <updated>2023-10-09T00:00:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://hbche.github.io/my-website/blog"/>
    <subtitle>小车的小书屋 Blog</subtitle>
    <icon>https://hbche.github.io/my-website/img/favicon.ico</icon>
    <entry>
        <title type="html"><![CDATA[Rust 所有权]]></title>
        <id>https://hbche.github.io/my-website/blog/2023/10/09/rust-ownership</id>
        <link href="https://hbche.github.io/my-website/blog/2023/10/09/rust-ownership"/>
        <updated>2023-10-09T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[记录 Rust 学习过程]]></summary>
        <content type="html"><![CDATA[<p>所有权（系统）是 Rust 最为与众不同的特性，它让 Rust 无需垃圾回收器（garbage collector）即可保证内存安全。因此，理解 Rust 中所有权的运作方式非常重要。在本章中，我们将讨论所有权以及相关功能：借用、slice 以及 Rust 如何在内存中存放数据。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="什么是所有权">什么是所有权<a href="#什么是所有权" class="hash-link" aria-label="什么是所有权的直接链接" title="什么是所有权的直接链接">​</a></h2><p>所有运行的程序都必须管理其使用计算机内存的方式。一些语言中具有垃圾回收机制，在程序运行时不断地寻找不再使用的内存；在另一些语言中，开发者必须亲自分配和释放内存。Rust 则选择了第三种方式：通过所有权系统管理内存，编译器在编译时会根据一系列的规则进行检查。在运行时，所有权系统的任何功能都不会减慢程序。</p><details class="details_lb9f alert alert--info details_b_Ee" data-collapsed="true"><summary><b>栈（Stack）与堆（Heap）</b></summary><div><div class="collapsibleContent_i85q"><p>在很多语言中，你并不需要经常考虑到栈与堆。不过在像 Rust 这样的系统编程语言中，值是位于栈上还是堆上在很大程度上影响了语言的行为以及为何必须做出这样的抉择。</p><p>栈和堆都是代码在运行时可供使用的内存，但是它们的结构不同。栈以放入值的顺序存储值并以相反顺序取出值。这也被称作 <strong>后进先出</strong>（last in, first out）。想象一下一叠盘子：当增加更多盘子时，把它们放在盘子堆的顶部，当需要盘子时，也从顶部拿走。不能从中间也不能从底部增加或拿走盘子！增加数据叫做 <strong>进栈</strong>（pushing onto the stack），而移出数据叫做 <strong>出栈</strong>（popping off the stack）。</p><p>栈中的所有数据都必须占用<strong>已知且固定的大小</strong>。在编译时大小未知或大小可能变化的数据，要改为存储在堆上。堆是缺乏组织的：当向堆放入数据时，你要请求一定大小的空间。内存分配器（memory allocator）在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的 <strong>指针</strong>（pointer）。这个过程称作 <strong>在堆上分配内存</strong>（allocating on the heap），有时简称为 “分配”（allocating）。将数据推入栈中并不被认为是分配。因为指针的大小是已知并且固定的，你可以将指针存储在栈上，不过当需要实际数据时，必须访问指针。</p><p>想象一下去餐馆就座吃饭。当进入时，你说明有几个人，餐馆员工会找到一个够大的空桌子并领你们过去。如果有人来迟了，他们也可以通过询问来找到你们坐在哪。</p><p>入栈比在堆上分配内存要快，因为（入栈时）分配器无需为存储新数据去搜索内存空间；其位置总是在栈顶。相比之下，在堆上分配内存则需要更多的工作，这是因为分配器必须首先找到一块足够存放数据的内存空间，并接着做一些记录为下一次分配做准备。</p><p>访问堆上的数据比访问栈上的数据慢，因为<strong>必须通过指针来访问</strong>。现代处理器在内存中跳转越少就越快（缓存）。继续类比，假设有一个服务员在餐厅里处理多个桌子的点菜。在一个桌子报完所有菜后再移动到下一个桌子是最有效率的。从桌子 A 听一个菜，接着桌子 B 听一个菜，然后再桌子 A，然后再桌子 B 这样的流程会更加缓慢。出于同样原因，处理器在处理的数据彼此较近的时候（比如在栈上）比较远的时候（比如可能在堆上）能更好的工作。在堆上分配大量的空间也可能消耗时间。</p><p>当你的代码调用一个函数时，传递给函数的值（包括可能指向堆上数据的指针）和函数的局部变量被压入栈中。当函数结束时，这些值被移出栈。</p><p>跟踪哪部分代码正在使用堆上的哪些数据，最大限度地减少堆上的重复数据量，以及清理堆上不再使用的数据确保不会耗尽空间，这些问题正是所有权系统要处理的。一旦理解了所有权，你就不需要经常考虑栈和堆了，不过明白了所有权的存在就是为了管理堆数据，能够帮助解释为什么所有权要以这种方式工作。</p></div></div></details><h3 class="anchor anchorWithStickyNavbar_LWe7" id="所有权规则">所有权规则<a href="#所有权规则" class="hash-link" aria-label="所有权规则的直接链接" title="所有权规则的直接链接">​</a></h3><p>首先，让我们看一下所有权的规则。当我们通过举例说明时，请谨记这些规则：</p><ul><li>Rust 中的每一个值都有一个被称为其 <strong>所有者</strong> (owner) 的变量</li><li>值在任一时刻有且只有一个所有者</li><li>当所有者（变量）离开作用域，这个值将被丢弃</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="变量与作用域">变量与作用域<a href="#变量与作用域" class="hash-link" aria-label="变量与作用域的直接链接" title="变量与作用域的直接链接">​</a></h3><p>在所有权的第一个例子中，我们看看一些变量的 <strong>作用域</strong>（scope）。作用域是一个项（item）在程序中有效的范围。假设有这样一个变量：</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">let s = String::from("hello");</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>变量 <code>s</code> 绑定到了一个字符串字面量，这个字符串值是硬编码进程序代码中的。该变量从声明的那一刻开始直到当前 <strong>作用域</strong> 结束时都是有效的。下面的示例给出了变量 <code>s</code> 的有效范围:</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">{   // s 在这里无效, 它尚未声明</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let s = String::from("hello");  // 从此处起, s 开始有效</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    // 使用 s</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}   // 此作用域已经结束, s 不再有效</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>换句话说，这里有两个重要的时间点：</p><ul><li>当 <code>s</code> <strong>进入作用域</strong> 时，它就是有效的。</li><li>这一直持续到它 <strong>离开作用域</strong> 为止。</li></ul><p>目前为止，变量是否有效与作用域的关系跟其他编程语言是类似的。现在我们在此基础上介绍 <code>String</code> 类型。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="string-类型">String 类型<a href="#string-类型" class="hash-link" aria-label="String 类型的直接链接" title="String 类型的直接链接">​</a></h3><p>字符串字面量是很方便的，不过它们并不适合使用文本的每一种场景。原因之一就是它们是不可变的。另一个原因是并非所有字符串的值都能在编写代码时就知道：例如，要是想获取用户输入并存储该怎么办呢？为此，Rust 有第二个字符串类型，<code>String</code>。这个类型管理被分配到堆上的数据，所以能够存储在编译时未知大小的文本。可以使用 <code>from</code> 函数基于字符串字面量来创建 <code>String</code>，如下：</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">let s = String::from("Hello");</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>双冒号（::）运算符允许我们将特定的 <code>from</code> 函数置于 <code>String</code> 类型的命名空间（namespace）下。</p><p>可以 修改此类字符串 ：</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">let mut s = String::from("Hello");</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">s.push_str(", world!");</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">println!("{}", s);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>那么这里有什么区别呢？为什么 String 可变而字面量却不行呢？区别在于两个类型对内存的处理上。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="内存与分配">内存与分配<a href="#内存与分配" class="hash-link" aria-label="内存与分配的直接链接" title="内存与分配的直接链接">​</a></h3><p>就字符串字面量来说，我们在编译时就知道其内容，所以文本被直接硬编码进最终的可执行文件中。这使得字符串字面量快速且高效。不过这些特性都只得益于字符串字面量的不可变性。不幸的是，我们不能为了每一个在编译时大小未知的文本而将一块内存放入二进制文件中，并且它的大小还可能随着程序运行而改变。</p><details class="details_lb9f alert alert--info details_b_Ee" data-collapsed="true"><summary>字符串字面量与字符串变量内存分布</summary><div><div class="collapsibleContent_i85q">在Rust中，字符串字面量（string literals）是在栈（stack）上存储的。<p>在 Rust 的内存管理中，堆（heap）和栈（stack）是两种主要的方式。栈用于存储局部变量和函数调用的信息，其存储的数据在函数调用结束后就会被销毁。而堆则是用于动态分配内存，存储全局变量或长期存活的数据。</p><p>字符串字面量是一种在编译时就已知其内容的字符串，因此它们被存储在程序的代码段中，也就是栈上。当然，如果你通过动态分配的方式（如使用 <code>String</code> 类型）创建字符串，那么这些字符串将会在堆上分配内存。</p><p>以下是一个简单的例子来说明这个问题：</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let s1 = "Hello, world!"; // 字符串字面量，存储在栈上</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let s2 = String::from("Hello, world!"); // 动态分配的字符串，存储在堆上</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在这个例子中，<code>s1</code> 是一个字符串字面量，它会在栈上分配内存。而 <code>s2</code> 是通过 <code>String::from</code> 动态分配的字符串，它会在堆上分配内存。</p><p>需要注意的是，尽管字符串字面量在栈上，但由于它们的生命周期与程序的生命周期相同（它们是全局的），所以它们实际上是不会被销毁的。</p></div></div></details><p>对于 <code>String</code> 类型，为了支持一个可变，可增长的文本片段，需要在堆上分配一块在编译时未知大小的内存来存放内容。这意味着：</p><ul><li>必须在运行时向内存分配器请求内存。</li><li>需要一个当我们处理完 <code>String</code> 时将内存返回给分配器的方法。</li></ul><p>第一部分由我们完成：当调用 <code>String::from</code> 时，它的实现（implementation）请求其所需的内存。这在编程语言中是非常通用的。</p><p>然而，第二部分实现起来就各有区别了。在有 <strong>垃圾回收</strong>（garbage collector，GC）的语言中， <code>GC</code> 记录并清除不再使用的内存，而我们并不需要关心它。没有 <code>GC</code> 的话，识别出不再使用的内存并调用代码显式释放就是我们的责任了，跟请求内存的时候一样。从历史的角度上说正确处理内存回收曾经是一个困难的编程问题。如果忘记回收了会浪费内存。如果过早回收了，将会出现无效变量。如果重复回收，这也是个 bug。我们需要精确地为一个 <code>allocate</code> 配对一个 <code>free</code>。</p><p>Rust 采取了一个不同的策略：内存在拥有它的变量离开作用域后就被自动释放。下面是示例中作用域例子的一个使用 <code>String</code> 而不是字符串字面量的版本：</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        let s = String::from("hello"); // 从此处起，s 开始有效</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        // 使用 s</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }                                  // 此作用域已结束，</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                                       // s 不再有效</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这是一个将 <code>String</code> 需要的内存返回给分配器的很自然的位置：当 s 离开作用域的时候。当变量离开作用域，Rust 为我们调用一个特殊的函数。这个函数叫做 <code>drop</code>，在这里 <code>String</code> 的作者可以放置释放内存的代码。Rust 在结尾的 <code>}</code> 处自动调用 <code>drop</code>。</p><blockquote><p>注意：在 C++ 中，这种 item 在生命周期结束时释放资源的模式有时被称作 资源获取即初始化（Resource Acquisition Is Initialization (RAII)）。如果你使用过 RAII 模式的话应该对 Rust 的 drop 函数并不陌生。</p></blockquote><p>这个模式对编写 Rust 代码的方式有着深远的影响。现在它看起来很简单，不过在更复杂的场景下代码的行为可能是不可预测的，比如当有多个变量使用在堆上分配的内存时。现在让我们探索一些这样的场景。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="变量与数据交互的方式一移动">变量与数据交互的方式（一）：移动<a href="#变量与数据交互的方式一移动" class="hash-link" aria-label="变量与数据交互的方式（一）：移动的直接链接" title="变量与数据交互的方式（一）：移动的直接链接">​</a></h3><p>在 Rust 中，多个变量能够以不同的方式与同一数据交互。让我们看看下面的示例:</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">let x = 5;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">let y = x;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>我们大致可以猜到这在干什么：“将 <code>5</code> 绑定到 <code>x</code>；接着生成一个值 <code>x</code> 的拷贝并绑定到 <code>y</code>”。现在有了两个变量，<code>x</code> 和 <code>y</code>，都等于 <code>5</code>。这也正是事实上发生了的，因为整数是有已知固定大小的简单值，所以这两个 <code>5</code> 被放入了栈中。</p><p>现在看看这个 <code>String</code> 版本：</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">let s1 = String::from("hello");</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">let s2 = s1;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这看起来与上面的代码非常类似，所以我们可能会假设他们的运行方式也是类似的：也就是说，第二行可能会生成一个 <code>s1</code> 的拷贝并绑定到 <code>s2</code> 上。不过，事实上并不完全是这样。</p><p>看看下图图以了解 <code>String</code> 的底层会发生什么。<code>String</code> 由三部分组成，如图左侧所示：一个指向存放字符串内容内存的指针，一个长度，和一个容量。这一组数据存储在栈上。右侧则是堆上存放内容的内存部分。</p><p><img loading="lazy" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIKICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPgo8IS0tIEdlbmVyYXRlZCBieSBncmFwaHZpeiB2ZXJzaW9uIDIuNDAuMSAoMjAxNjEyMjUuMDMwNCkKIC0tPgo8IS0tIFRpdGxlOiAlMyBQYWdlczogMSAtLT4KPHN2Zwogdmlld0JveD0iMC4wMCAwLjAwIDEwMDAuMDAgNzAwLjAwIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIj4KPGcgaWQ9ImdyYXBoMCIgY2xhc3M9ImdyYXBoIiB0cmFuc2Zvcm09InNjYWxlKDQuMTY2NyA0LjE2NjcpIHJvdGF0ZSgwKSB0cmFuc2xhdGUoNCAxNTIpIj4KPHRpdGxlPiUzPC90aXRsZT4KPHBvbHlnb24gZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSJ0cmFuc3BhcmVudCIgcG9pbnRzPSItNCw0IC00LC0xNTIgMjMzLC0xNTIgMjMzLDQgLTQsNCIvPgo8IS0tIHRhYmxlMCAtLT4KPGcgaWQ9Im5vZGUxIiBjbGFzcz0ibm9kZSI+Cjx0aXRsZT50YWJsZTA8L3RpdGxlPgo8cG9seWxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBwb2ludHM9IjgsLTEyNCA5NiwtMTI0ICIvPgo8dGV4dCB0ZXh0LWFuY2hvcj0ic3RhcnQiIHg9IjQ1Ljc3NTkiIHk9Ii0xMjkuOCIgZm9udC1mYW1pbHk9IlRpbWVzLHNlcmlmIiBmb250LXNpemU9IjE0LjAwIiBmaWxsPSIjMDAwMDAwIj5zMTwvdGV4dD4KPHBvbHlnb24gZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBwb2ludHM9IjgsLTEwNCA4LC0xMjQgNjAsLTEyNCA2MCwtMTA0IDgsLTEwNCIvPgo8dGV4dCB0ZXh0LWFuY2hvcj0ic3RhcnQiIHg9IjE4Ljg0MTMiIHk9Ii0xMDkuOCIgZm9udC1mYW1pbHk9IlRpbWVzLHNlcmlmIiBmb250LXNpemU9IjE0LjAwIiBmaWxsPSIjMDAwMDAwIj5uYW1lPC90ZXh0Pgo8cG9seWdvbiBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAwMDAiIHBvaW50cz0iNjAsLTEwNCA2MCwtMTI0IDk2LC0xMjQgOTYsLTEwNCA2MCwtMTA0Ii8+Cjx0ZXh0IHRleHQtYW5jaG9yPSJzdGFydCIgeD0iNjIuODQxMyIgeT0iLTEwOS44IiBmb250LWZhbWlseT0iVGltZXMsc2VyaWYiIGZvbnQtc2l6ZT0iMTQuMDAiIGZpbGw9IiMwMDAwMDAiPnZhbHVlPC90ZXh0Pgo8cG9seWdvbiBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAwMDAiIHBvaW50cz0iOCwtODQgOCwtMTA0IDYwLC0xMDQgNjAsLTg0IDgsLTg0Ii8+Cjx0ZXh0IHRleHQtYW5jaG9yPSJzdGFydCIgeD0iMjYuMjI0MSIgeT0iLTg5LjgiIGZvbnQtZmFtaWx5PSJUaW1lcyxzZXJpZiIgZm9udC1zaXplPSIxNC4wMCIgZmlsbD0iIzAwMDAwMCI+cHRyPC90ZXh0Pgo8cG9seWdvbiBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAwMDAiIHBvaW50cz0iNjAsLTg0IDYwLC0xMDQgOTYsLTEwNCA5NiwtODQgNjAsLTg0Ii8+Cjxwb2x5Z29uIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgcG9pbnRzPSI4LC02NCA4LC04NCA2MCwtODQgNjAsLTY0IDgsLTY0Ii8+Cjx0ZXh0IHRleHQtYW5jaG9yPSJzdGFydCIgeD0iMjUuNDQ4MiIgeT0iLTY5LjgiIGZvbnQtZmFtaWx5PSJUaW1lcyxzZXJpZiIgZm9udC1zaXplPSIxNC4wMCIgZmlsbD0iIzAwMDAwMCI+bGVuPC90ZXh0Pgo8cG9seWdvbiBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAwMDAiIHBvaW50cz0iNjAsLTY0IDYwLC04NCA5NiwtODQgOTYsLTY0IDYwLC02NCIvPgo8dGV4dCB0ZXh0LWFuY2hvcj0ic3RhcnQiIHg9Ijc0LjUiIHk9Ii02OS44IiBmb250LWZhbWlseT0iVGltZXMsc2VyaWYiIGZvbnQtc2l6ZT0iMTQuMDAiIGZpbGw9IiMwMDAwMDAiPjU8L3RleHQ+Cjxwb2x5Z29uIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgcG9pbnRzPSI4LC00NCA4LC02NCA2MCwtNjQgNjAsLTQ0IDgsLTQ0Ii8+Cjx0ZXh0IHRleHQtYW5jaG9yPSJzdGFydCIgeD0iMTAuNjgyNiIgeT0iLTQ5LjgiIGZvbnQtZmFtaWx5PSJUaW1lcyxzZXJpZiIgZm9udC1zaXplPSIxNC4wMCIgZmlsbD0iIzAwMDAwMCI+Y2FwYWNpdHk8L3RleHQ+Cjxwb2x5Z29uIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgcG9pbnRzPSI2MCwtNDQgNjAsLTY0IDk2LC02NCA5NiwtNDQgNjAsLTQ0Ii8+Cjx0ZXh0IHRleHQtYW5jaG9yPSJzdGFydCIgeD0iNzQuNSIgeT0iLTQ5LjgiIGZvbnQtZmFtaWx5PSJUaW1lcyxzZXJpZiIgZm9udC1zaXplPSIxNC4wMCIgZmlsbD0iIzAwMDAwMCI+NTwvdGV4dD4KPC9nPgo8IS0tIHRhYmxlMSAtLT4KPGcgaWQ9Im5vZGUyIiBjbGFzcz0ibm9kZSI+Cjx0aXRsZT50YWJsZTE8L3RpdGxlPgo8cG9seWdvbiBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAwMDAiIHBvaW50cz0iMTQ4LjUsLTEwNCAxNDguNSwtMTI0IDE4NS41LC0xMjQgMTg1LjUsLTEwNCAxNDguNSwtMTA0Ii8+Cjx0ZXh0IHRleHQtYW5jaG9yPSJzdGFydCIgeD0iMTUxLjQ0ODIiIHk9Ii0xMDkuOCIgZm9udC1mYW1pbHk9IlRpbWVzLHNlcmlmIiBmb250LXNpemU9IjE0LjAwIiBmaWxsPSIjMDAwMDAwIj5pbmRleDwvdGV4dD4KPHBvbHlnb24gZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBwb2ludHM9IjE4NS41LC0xMDQgMTg1LjUsLTEyNCAyMjEuNSwtMTI0IDIyMS41LC0xMDQgMTg1LjUsLTEwNCIvPgo8dGV4dCB0ZXh0LWFuY2hvcj0ic3RhcnQiIHg9IjE4OC4zNDEzIiB5PSItMTA5LjgiIGZvbnQtZmFtaWx5PSJUaW1lcyxzZXJpZiIgZm9udC1zaXplPSIxNC4wMCIgZmlsbD0iIzAwMDAwMCI+dmFsdWU8L3RleHQ+Cjxwb2x5Z29uIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgcG9pbnRzPSIxNDguNSwtODQgMTQ4LjUsLTEwNCAxODUuNSwtMTA0IDE4NS41LC04NCAxNDguNSwtODQiLz4KPHRleHQgdGV4dC1hbmNob3I9InN0YXJ0IiB4PSIxNjMuNSIgeT0iLTg5LjgiIGZvbnQtZmFtaWx5PSJUaW1lcyxzZXJpZiIgZm9udC1zaXplPSIxNC4wMCIgZmlsbD0iIzAwMDAwMCI+MDwvdGV4dD4KPHBvbHlnb24gZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBwb2ludHM9IjE4NS41LC04NCAxODUuNSwtMTA0IDIyMS41LC0xMDQgMjIxLjUsLTg0IDE4NS41LC04NCIvPgo8dGV4dCB0ZXh0LWFuY2hvcj0ic3RhcnQiIHg9IjIwMCIgeT0iLTg5LjgiIGZvbnQtZmFtaWx5PSJUaW1lcyxzZXJpZiIgZm9udC1zaXplPSIxNC4wMCIgZmlsbD0iIzAwMDAwMCI+aDwvdGV4dD4KPHBvbHlnb24gZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBwb2ludHM9IjE0OC41LC02NCAxNDguNSwtODQgMTg1LjUsLTg0IDE4NS41LC02NCAxNDguNSwtNjQiLz4KPHRleHQgdGV4dC1hbmNob3I9InN0YXJ0IiB4PSIxNjMuNSIgeT0iLTY5LjgiIGZvbnQtZmFtaWx5PSJUaW1lcyxzZXJpZiIgZm9udC1zaXplPSIxNC4wMCIgZmlsbD0iIzAwMDAwMCI+MTwvdGV4dD4KPHBvbHlnb24gZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBwb2ludHM9IjE4NS41LC02NCAxODUuNSwtODQgMjIxLjUsLTg0IDIyMS41LC02NCAxODUuNSwtNjQiLz4KPHRleHQgdGV4dC1hbmNob3I9InN0YXJ0IiB4PSIyMDAuMzkzMSIgeT0iLTY5LjgiIGZvbnQtZmFtaWx5PSJUaW1lcyxzZXJpZiIgZm9udC1zaXplPSIxNC4wMCIgZmlsbD0iIzAwMDAwMCI+ZTwvdGV4dD4KPHBvbHlnb24gZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBwb2ludHM9IjE0OC41LC00NCAxNDguNSwtNjQgMTg1LjUsLTY0IDE4NS41LC00NCAxNDguNSwtNDQiLz4KPHRleHQgdGV4dC1hbmNob3I9InN0YXJ0IiB4PSIxNjMuNSIgeT0iLTQ5LjgiIGZvbnQtZmFtaWx5PSJUaW1lcyxzZXJpZiIgZm9udC1zaXplPSIxNC4wMCIgZmlsbD0iIzAwMDAwMCI+MjwvdGV4dD4KPHBvbHlnb24gZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBwb2ludHM9IjE4NS41LC00NCAxODUuNSwtNjQgMjIxLjUsLTY0IDIyMS41LC00NCAxODUuNSwtNDQiLz4KPHRleHQgdGV4dC1hbmNob3I9InN0YXJ0IiB4PSIyMDEuNTU1MiIgeT0iLTQ5LjgiIGZvbnQtZmFtaWx5PSJUaW1lcyxzZXJpZiIgZm9udC1zaXplPSIxNC4wMCIgZmlsbD0iIzAwMDAwMCI+bDwvdGV4dD4KPHBvbHlnb24gZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBwb2ludHM9IjE0OC41LC0yNCAxNDguNSwtNDQgMTg1LjUsLTQ0IDE4NS41LC0yNCAxNDguNSwtMjQiLz4KPHRleHQgdGV4dC1hbmNob3I9InN0YXJ0IiB4PSIxNjMuNSIgeT0iLTI5LjgiIGZvbnQtZmFtaWx5PSJUaW1lcyxzZXJpZiIgZm9udC1zaXplPSIxNC4wMCIgZmlsbD0iIzAwMDAwMCI+MzwvdGV4dD4KPHBvbHlnb24gZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBwb2ludHM9IjE4NS41LC0yNCAxODUuNSwtNDQgMjIxLjUsLTQ0IDIyMS41LC0yNCAxODUuNSwtMjQiLz4KPHRleHQgdGV4dC1hbmNob3I9InN0YXJ0IiB4PSIyMDEuNTU1MiIgeT0iLTI5LjgiIGZvbnQtZmFtaWx5PSJUaW1lcyxzZXJpZiIgZm9udC1zaXplPSIxNC4wMCIgZmlsbD0iIzAwMDAwMCI+bDwvdGV4dD4KPHBvbHlnb24gZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBwb2ludHM9IjE0OC41LC00IDE0OC41LC0yNCAxODUuNSwtMjQgMTg1LjUsLTQgMTQ4LjUsLTQiLz4KPHRleHQgdGV4dC1hbmNob3I9InN0YXJ0IiB4PSIxNjMuNSIgeT0iLTkuOCIgZm9udC1mYW1pbHk9IlRpbWVzLHNlcmlmIiBmb250LXNpemU9IjE0LjAwIiBmaWxsPSIjMDAwMDAwIj40PC90ZXh0Pgo8cG9seWdvbiBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAwMDAiIHBvaW50cz0iMTg1LjUsLTQgMTg1LjUsLTI0IDIyMS41LC0yNCAyMjEuNSwtNCAxODUuNSwtNCIvPgo8dGV4dCB0ZXh0LWFuY2hvcj0ic3RhcnQiIHg9IjIwMCIgeT0iLTkuOCIgZm9udC1mYW1pbHk9IlRpbWVzLHNlcmlmIiBmb250LXNpemU9IjE0LjAwIiBmaWxsPSIjMDAwMDAwIj5vPC90ZXh0Pgo8L2c+CjwhLS0gdGFibGUwJiM0NTsmZ3Q7dGFibGUxIC0tPgo8ZyBpZD0iZWRnZTEiIGNsYXNzPSJlZGdlIj4KPHRpdGxlPnRhYmxlMDpjJiM0NTsmZ3Q7dGFibGUxOnBvaW50ZWU8L3RpdGxlPgo8cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiMwMDAwMDAiIGQ9Ik03OCwtOTRDNzgsLTk0IDEwOS4zNDA2LC05NCAxMzguMzc5NywtOTQiLz4KPHBvbHlnb24gZmlsbD0iIzAwMDAwMCIgc3Ryb2tlPSIjMDAwMDAwIiBwb2ludHM9IjEzOC41LC05Ny41MDAxIDE0OC41LC05NCAxMzguNSwtOTAuNTAwMSAxMzguNSwtOTcuNTAwMSIvPgo8L2c+CjwvZz4KPC9zdmc+Cg==" width="1000" height="700" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="变量与数据交互的方式二克隆">变量与数据交互的方式（二）：克隆<a href="#变量与数据交互的方式二克隆" class="hash-link" aria-label="变量与数据交互的方式（二）：克隆的直接链接" title="变量与数据交互的方式（二）：克隆的直接链接">​</a></h3><h3 class="anchor anchorWithStickyNavbar_LWe7" id="只在栈上的数据拷贝">只在栈上的数据：拷贝<a href="#只在栈上的数据拷贝" class="hash-link" aria-label="只在栈上的数据：拷贝的直接链接" title="只在栈上的数据：拷贝的直接链接">​</a></h3><h3 class="anchor anchorWithStickyNavbar_LWe7" id="所有权与函数">所有权与函数<a href="#所有权与函数" class="hash-link" aria-label="所有权与函数的直接链接" title="所有权与函数的直接链接">​</a></h3><p>将值传递给函数在语义上与给变量赋值相似。向函数传递值可能会移动或者复制，就像赋值语句一样。</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let s = String::from("Hello ownership");</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    takes_ownership(s);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let i = 5;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    makes_copy(i);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn takes_ownership(some_string: String) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    println!("{}", some_string);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn makes_copy(some_integer: i32) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    println!("{}", some_integer);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>当尝试在调用 <code>takes_ownership</code> 后使用 <code>s</code> 时，Rust 会抛出一个编译时错误。这些静态检查使我们免于犯错。试试在 <code>main</code> 函数中添加使用 <code>s</code> 和 <code>x</code> 的代码来看看哪里能使用他们，以及所有权规则会在哪里阻止我们这么做。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="返回值与作用域">返回值与作用域<a href="#返回值与作用域" class="hash-link" aria-label="返回值与作用域的直接链接" title="返回值与作用域的直接链接">​</a></h3><p>返回值也可以转移所有权。</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  let s1 = gives_ownership();         // gives_ownership 将返回值</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                                      // 移给 s1</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  let s2 = String::from("hello");     // s2 进入作用域</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  let s3 = takes_and_gives_back(s2);  // s2 被移动到</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                                      // takes_and_gives_back 中,</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                                      // 它也将返回值移给 s3</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">} // 这里, s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走，</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  // 所以什么也不会发生。s1 移出作用域并被丢弃</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn gives_ownership() -&gt; String {           // gives_ownership 将返回值移动给</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                                           // 调用它的函数</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  let some_string = String::from("yours"); // some_string 进入作用域</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  some_string                              // 返回 some_string 并移出给调用的函数</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">// takes_and_gives_back 将传入字符串并返回该值</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn takes_and_gives_back(a_string: String) -&gt; String { // a_string 进入作用域</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  a_string  // 返回 a_string 并移出给调用的函数</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>变量的所有权总是遵循相同的模式：将值赋给另一个变量时移动它。当持有堆中数据值的变量离开作用域时，其值将通过 <code>drop</code> 被清理掉，除非数据被移动为另一个变量所有。</p><p>在每一个函数中都获取所有权并接着返回所有权有些啰嗦。如果我们想要函数使用一个值但不获取所有权该怎么办呢？如果我们还要接着使用它的话，每次都传进去再返回来就有点烦人了，除此之外，我们也可能想返回函数体中产生的一些数据。</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let s1 = String::from("hello");</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let (s2, len) = calculate_length(s1);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    println!("The length of '{}' is {}.", s2, len);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn calculate_length(s: String) -&gt; (String, usize) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let length = s.len(); // len() 返回字符串的长度</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    (s, length)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>但是这未免有些形式主义，而且这种场景应该很常见。幸运的是，Rust 对此提供了一个功能，叫做 <strong>引用</strong>（references）。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="问答">问答<a href="#问答" class="hash-link" aria-label="问答的直接链接" title="问答的直接链接">​</a></h3><ol><li><p>Rust 的所有权是否与其存储形式有关?</p><details class="details_lb9f alert alert--info details_b_Ee" data-collapsed="true"><summary>点击查看答案</summary><div><div class="collapsibleContent_i85q">在Rust中，所有权（ownership）是一个重要的概念，它与变量绑定和生命周期密切相关。然而，所有权并不直接与数据是否存储在栈上或堆上有关。<p>在 Rust 中，每个变量都有一个独特的所有权，这意味着只有一个变量可以拥有某个值的所有权。一旦变量离开其作用域，其所有权就会失效，该值就会变成无效的。</p><p>对于在栈上存储的数据，所有权通常与函数中的局部变量绑定。当函数执行时，这些变量被创建并存储在栈上，它们在函数的作用域内拥有其值。当函数执行完毕并返回时，这些变量的所有权会失效，它们的值会被销毁。</p><p>与此类似，堆上的数据也具有所有权，但该所有权是通过引用和生命周期来管理的。对于通过引用分配在堆上的数据，其所有权与引用一起存在，只要引用仍然有效，该数据的所有权就不会失效。一旦引用失效或被解引用，该数据的所有权就会失效，相应的内存就会变成无效的。</p><p>因此，尽管在 Rust 中数据的存储位置（栈或堆）与其所有权的管理方式有关，但它们是两个独立的概念。数据的存储位置取决于其分配方式（静态分配或动态分配），而数据的所有权则取决于其绑定方式和生命周期。</p></div></div></details></li></ol>]]></content>
        <author>
            <name>Hanbin Che</name>
            <uri>https://github.com/hbche</uri>
        </author>
        <category label="rust" term="rust"/>
        <category label="所有权" term="所有权"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Rust 结构体]]></title>
        <id>https://hbche.github.io/my-website/blog/2023/10/09/rust-structure</id>
        <link href="https://hbche.github.io/my-website/blog/2023/10/09/rust-structure"/>
        <updated>2023-10-09T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[记录 Rust 学习过程]]></summary>
        <content type="html"><![CDATA[<h2 class="anchor anchorWithStickyNavbar_LWe7" id="定义和举例说明结构体">定义和举例说明结构体<a href="#定义和举例说明结构体" class="hash-link" aria-label="定义和举例说明结构体的直接链接" title="定义和举例说明结构体的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="定义并实例化结构体">定义并实例化结构体<a href="#定义并实例化结构体" class="hash-link" aria-label="定义并实例化结构体的直接链接" title="定义并实例化结构体的直接链接">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="变量与字段同名时的字段初始化简写语法">变量与字段同名时的字段初始化简写语法<a href="#变量与字段同名时的字段初始化简写语法" class="hash-link" aria-label="变量与字段同名时的字段初始化简写语法的直接链接" title="变量与字段同名时的字段初始化简写语法的直接链接">​</a></h4><h4 class="anchor anchorWithStickyNavbar_LWe7" id="使用结构体更新语法从其他实例创建实例">使用结构体更新语法从其他实例创建实例<a href="#使用结构体更新语法从其他实例创建实例" class="hash-link" aria-label="使用结构体更新语法从其他实例创建实例的直接链接" title="使用结构体更新语法从其他实例创建实例的直接链接">​</a></h4>]]></content>
        <author>
            <name>Hanbin Che</name>
            <uri>https://github.com/hbche</uri>
        </author>
        <category label="rust" term="rust"/>
        <category label="结构体" term="结构体"/>
        <category label="入门" term="入门"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Rust 通用编程概念 - 控制流]]></title>
        <id>https://hbche.github.io/my-website/blog/2023/10/08/control-flow</id>
        <link href="https://hbche.github.io/my-website/blog/2023/10/08/control-flow"/>
        <updated>2023-10-08T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[记录 Rust 学习过程]]></summary>
        <content type="html"><![CDATA[<p>根据条件是否为真来决定是否执行某些代码，或根据条件是否为真来重复运行一段代码，是大部分编程语言的基本组成部分。Rust 代码中最常见的用来控制执行流的结构是 <code>if</code> 表达式和循环。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="if-表达式">if 表达式<a href="#if-表达式" class="hash-link" aria-label="if 表达式的直接链接" title="if 表达式的直接链接">​</a></h2><p><code>if</code> 表达式允许根据条件执行不同的代码分支。你提供一个条件并表示 “如果条件满足，运行这段代码；如果条件不满足，不运行这段代码。”</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">use std::io;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn even_number(num: i32) -&gt; bool {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    num % 2 == 0</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    println!("Please input a number");</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let mut number = String::new();</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    io::stdin()</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        .read_line(&amp;mut number)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        .expect("Failed to read line");</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    // number 转换之前必须使用 trim 函数对其结尾的换行转移进行删除,否则 parse 函数调用将报异常</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let number = number.trim().parse().expect("Failed to parse number");</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let is_even = even_number(number);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    if is_even {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        println!("{} is even number.", number);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        println!("{} is odd number.", number);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>输出:</p><div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">PS E:\github\rust-projects\branches&gt; cargo run</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">   Compiling branches v0.1.0 (E:\github\rust-projects\branches)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    Finished dev [unoptimized + debuginfo] target(s) in 0.45s</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">     Running </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`target\debug\branches.exe`</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">Please input a number</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">23</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">23 is odd number.</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>所有的 <code>if</code> 表达式都以 <code>if</code> 关键字开头，其后跟一个条件。在这个例子中，我们首先定义了一个函数 <code>even_number</code> 用来判断一个数字是否是偶数，并返回 <code>bool</code> 类型的结果；接着我们在 <code>main</code> 函数中调用了该函数，参数是用户从控制台输入的数字；接下来使用 <code>if</code> 表达式根据 <code>even_number</code> 函数的返回值进行判断，最后使用 <code>println</code> 宏打印相应的结果，并用输入的数字回填到标准输入占位符的位置。</p><p>在条件为真时希望执行的代码块位于紧跟条件之后的大括号中。<code>if</code> 表达式中与条件关联的代码块有时被叫做<strong>分支</strong>（arm），也可以包含一个可选的 else 表达式来提供一个在条件为假时应当执行的代码块，这里我们就这么做了。如果不提供 else 表达式并且条件为假时，程序会直接忽略 if 代码块并继续执行下面的代码。</p><p>尝试输入不同的值，根据条件判断将会打印不同的结果。</p><p>另外值得注意的是代码中的条件必须是 <code>bool</code> 值。如果条件不是 <code>bool</code> 值，我们将得到一个错误。例如，尝试运行以下代码：</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let number = 3;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    if number {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        println!("number was three");</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这里 <code>if</code> 条件的值是 <code>3</code>，Rust 抛出了一个错误</p><div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">PS E:\github\rust-projects\branches&gt; cargo run</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">   Compiling branches v0.1.0 (E:\github\rust-projects\branches)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">error</span><span class="token url-reference url punctuation" style="color:rgb(248, 248, 242)">[</span><span class="token url-reference url variable" style="color:rgb(189, 147, 249);font-style:italic">E0308</span><span class="token url-reference url punctuation" style="color:rgb(248, 248, 242)">]</span><span class="token url-reference url punctuation" style="color:rgb(248, 248, 242)">:</span><span class="token url-reference url"> mismatched</span><span class="token plain"> types</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"> --&gt; src\main.rs:3:8</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">3 |     if number {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |        ^^^^^^ expected </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`bool`</span><span class="token plain">, found integer</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">For more information about this error, try </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`rustc --explain E0308`</span><span class="token plain">.</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">error: could not compile </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`branches`</span><span class="token plain"> (bin "branches") due to previous error</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这个错误表明 Rust 期望一个 <code>bool</code> 却得到了一个整数。不像 Ruby 或 JavaScript 这样的语言，Rust 并不会尝试自动地将非布尔值转换为布尔值。你必须自始至终显式地使用布尔值作为 <code>if</code> 的条件。例如，如果想要 <code>if</code> 代码块只在一个数字不等于 <code>0</code> 时执行，可以把 <code>if</code> 表达式修改成下面这样：</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let number = 3;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    if number != 0 {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        println!("number was something other than zero");</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>运行代码会打印出 <code>number was something other than zero</code>。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="使用-else-if-处理多重条件">使用 else if 处理多重条件<a href="#使用-else-if-处理多重条件" class="hash-link" aria-label="使用 else if 处理多重条件的直接链接" title="使用 else if 处理多重条件的直接链接">​</a></h3><p>可以将 <code>if</code> 和 <code>else</code> 组成的 <code>else if</code> 表达式来实现多重条件。例如：</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">use std::io;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let mut number = String::new();</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    println!("Please input a number: ");</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    io::stdin().read_line(&amp;mut number).expect("Input Failed.");</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let number: i32 = number.trim().parse().expect("Input is not a number.");</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    if number % 3 == 0 {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        println!("number is divisible by 3");</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    } else if number % 5 == 0 {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        println!("number is divisible by 5");</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    } else if number % 7 == 0 {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        println!("number is divisible by 7");</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        println!("number is not divisible by 3, 5, or 7");</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>输出:</p><div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">PS E:\github\rust-projects\branches&gt; cargo run</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">   Compiling branches v0.1.0 (E:\github\rust-projects\branches)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    Finished dev [unoptimized + debuginfo] target(s) in 0.82s</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">     Running </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`target\debug\branches.exe`</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">Please input a number:</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">15</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">number is divisible by 3</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>当执行这个程序时，它按顺序检查每个 <code>if</code> 表达式并执行第一个条件为真的代码块。注意及时 <code>15</code> 可以被 <code>5</code> 整除，也不会输出 <code>number is divisible by 5</code>，更不会输出 <code>else </code>块中的 <code>number is not divisible by 3, 5, or 7</code>。原因是 Rust 只会执行第一个条件为真的代码块，并且一旦它找到一个以后，甚至都不会检查剩下的条件了。</p><p>使用过多的 <code>else if</code> 表达式会使代码显得杂乱无章，所以如果有多于一个 <code>else if</code> 表达式，最好重构代码。为处理这些情况，可以使用 <code>match</code> 多分支结构。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="在-let-语句中使用-if">在 let 语句中使用 if<a href="#在-let-语句中使用-if" class="hash-link" aria-label="在 let 语句中使用 if的直接链接" title="在 let 语句中使用 if的直接链接">​</a></h3><p>因为 <code>if</code> 是一个<strong>表达式</strong>，我们可以在 <code>let</code> 语句的右侧使用它来将结果赋值给一个变量，如下示例：</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let condition = true;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let number = if condition { 5 } else { 6 };</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    println!("The value of number is: {}", number);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><code>number</code> 变量将会绑定到表示 <code>if</code> 表达式结果的值上。运行这段代码看看会出现什么：</p><div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">PS E:\github\rust-projects\branches&gt; cargo run</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">   Compiling branches v0.1.0 (E:\github\rust-projects\branches)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    Finished dev [unoptimized + debuginfo] target(s) in 0.21s</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">     Running </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`target\debug\branches.exe`</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">The value of number is: 5</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>记住，代码块的值是其最后一个表达式的值，而数字本身就是一个表达式。在这个例子中，整个 <code>if</code> 表达式的值取决于哪个代码块被执行。这意味着 <code>if</code> 的每个分支的可能的返回值都必须是相同类型；在上述示例中，<code>if</code> 分支和 <code>else</code> 分支的结果都是 <code>i32</code> 整型。如果它们的类型不匹配，如下面这个例子，则会产生一个错误：</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let condition = true;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let number = if condition { 5 } else { "six" };</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    println!("The value of number is: {}", number);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>当编译这段代码时，会得到一个错误。<code>if</code> 和 <code>else</code> 分支的值类型是不相容的，同时 Rust 也准确地指出在程序中的何处发现的这个问题：</p><div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">PS E:\github\rust-projects\branches&gt; cargo run</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">   Compiling branches v0.1.0 (E:\github\rust-projects\branches)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">error</span><span class="token url-reference url punctuation" style="color:rgb(248, 248, 242)">[</span><span class="token url-reference url variable" style="color:rgb(189, 147, 249);font-style:italic">E0308</span><span class="token url-reference url punctuation" style="color:rgb(248, 248, 242)">]</span><span class="token url-reference url punctuation" style="color:rgb(248, 248, 242)">:</span><span class="token url-reference url"> `if`</span><span class="token plain"> and </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`else`</span><span class="token plain"> have incompatible types</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"> --&gt; src\main.rs:3:44</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">3 |     let number = if condition { 5 } else { "six" };</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |                                 -          ^^^^^ expected integer, found </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`&amp;str`</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |                                 |</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |                                 expected because of this</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">For more information about this error, try </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`rustc --explain E0308`</span><span class="token plain">.</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">error: could not compile </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`branches`</span><span class="token plain"> (bin "branches") due to previous error</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><code>if</code> 代码块中的表达式返回一个整数，而 <code>else</code> 代码块中的表达式返回一个字符串。这不可行，因为变量必须只有一个类型。Rust 需要在编译时就确切地知道 <code>number</code> 变量的类型，这样它就可以在编译时验证在每处使用的 <code>number</code> 变量的类型是有效的。若 <code>number</code> 的类型仅在运行时确定，则 Rust 将无法做到这一点；而且若编译器必须跟踪任意变量的多种假设类型，则编译器会变得更复杂，并且对代码的保证也会减少。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="使用循环重复执行">使用循环重复执行<a href="#使用循环重复执行" class="hash-link" aria-label="使用循环重复执行的直接链接" title="使用循环重复执行的直接链接">​</a></h2><p>多次执行同一段代码是很常用的，Rust 为此提供了多种<strong>循环</strong>（loop），它们遍历执行循环体中的代码直到结尾并紧接着回到开头继续执行。为了试验循环，让我们新建一个名为 <em>loops</em> 的项目。</p><p>Rust 有三种循环：<code>loop</code>、<code>while</code> 和 <code>for</code>。我们每一个都试试。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="使用-loop-重复执行代码">使用 loop 重复执行代码<a href="#使用-loop-重复执行代码" class="hash-link" aria-label="使用 loop 重复执行代码的直接链接" title="使用 loop 重复执行代码的直接链接">​</a></h3><p><code>loop</code> 关键字告诉 Rust 一遍又一遍地执行一段代码直到你明确要求停止。</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    loop {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        println!("again!");</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>当运行这个程序时，我们会看到连续的反复打印 <code>again!</code>，直到我们手动停止程序。大部分终端都支持一个快捷键 <code>ctrl-c</code> 来终止一个陷入无限循环的程序。尝试一下：</p><div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">PS E:\github\rust-projects\loops&gt; cargo run</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    Finished dev [unoptimized + debuginfo] target(s) in 0.01s</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">     Running </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`target\debug\loops.exe`</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">again!</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">again!</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">again!</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">^Cagain!</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>符号 <code>^C</code> 代表你在这按下了<code>ctrl-c</code>。在 <code>^C</code> 之后你可能看到也可能看不到 <code>again!</code> ，这取决于在接收到终止信号时代码执行到了循环的何处。</p><p>幸运的是，Rust 也提供了一种从代码中跳出循环的方法。可以使用 <code>break</code> 关键字来告诉程序何时停止循环。</p><p>循环中的 <code>continue</code> 关键字告诉程序跳过这个循环迭代中的任何剩余代码，并转到下一个迭代。</p><p>如果存在嵌套循环，<code>break</code> 和 <code>continue</code> 应用于此时最内层的循环。你可以选择在一个循环上指定一个<strong>循环标签</strong>（loop label），然后将标签与 <code>break</code> 或 <code>continue</code> 一起使用，使这些关键字应用于已标记的循环而不是最内层的循环。下面是一个包含两个嵌套循环的示例：</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let mut count = 0;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    'counting_up: loop {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        println!("count = {}", count);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        let mut remaining = 10;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        loop {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            println!("remaining = {}", remaining);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            if remaining == 9 {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            if count == 2 {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                break 'counting_up;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            remaining -= 1;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        count += 1;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    println!("End count = {}", count);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>外层循环有一个标签 <code>counting_up</code>，它将从 <code>0</code> 数到 <code>2</code>。没有标签的内部循环从 <code>10</code> 向下数到 <code>9</code>。第一个没有指定标签的 <code>break</code> 将只退出内层循环。<code>break 'counting_up;</code> 语句将退出外层循环。这个代码打印:</p><div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">PS E:\github\rust-projects\loops&gt; cargo run</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">   Compiling loops v0.1.0 (E:\github\rust-projects\loops)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    Finished dev [unoptimized + debuginfo] target(s) in 0.47s</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">     Running </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`target\debug\loops.exe`</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">count = 0</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">remaining = 10</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">remaining = 9</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">count = 1</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">remaining = 10</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">remaining = 9</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">count = 2</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">remaining = 10</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">End count = 2</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="从循环返回">从循环返回<a href="#从循环返回" class="hash-link" aria-label="从循环返回的直接链接" title="从循环返回的直接链接">​</a></h3><p><code>loop</code> 的一个用例是重试可能会失败的操作，比如检查线程是否完成了任务。然而你可能会需要将操作的结果从循环中传递给其它的代码。为此，你可以在用于停止循环的 <code>break</code> 表达式添加你想要返回的值；该值将从循环中返回，以便您可以使用它，如下所示：</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let mut counter = 0;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let result = loop {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        counter += 1;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        if counter == 10 {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">            break counter * 2;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    println!("The result is {}", result);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在循环之前，我们声明了一个名为 <code>counter</code> 的变量并初始化为 <code>0</code>。接着声明了一个名为 <code>result</code> 来存放循环的返回值。在循环的每一次迭代中，我们将 <code>counter</code> 变量加 <code>1</code>，接着检查计数是否等于 <code>10</code>。当相等时，使用 <code>break</code> 关键字返回值 <code>counter * 2</code>。循环之后，我们通过分号结束赋值给 <code>result</code> 的语句。最后打印出 <code>result</code> 的值，也就是 <code>20</code>。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="while-条件循环">while 条件循环<a href="#while-条件循环" class="hash-link" aria-label="while 条件循环的直接链接" title="while 条件循环的直接链接">​</a></h3><p>在程序中计算循环的条件也很常见。当条件为真，执行循环。当条件不再为真，调用 <code>break</code> 停止循环。这个循环类型可以通过组合 <code>loop</code>、<code>if</code>、<code>else</code> 和 <code>break</code> 来实现；如果你喜欢的话，现在就可以在程序中试试。然而，这个模式太常用了，Rust 为此内置了一个语言结构，它被称为 <code>while</code> 循环。</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let mut number = 3;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    while number != 0 {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        println!("{}", number);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        number -= 1;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    println!("LIFTOFF!!!");</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这种结构消除了很多使用 <code>loop</code>、<code>if</code>、<code>else</code> 和 <code>break</code> 时所必须的嵌套，这样更加清晰。当条件为真就执行，否则退出循环。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="使用-for-遍历集合">使用 for 遍历集合<a href="#使用-for-遍历集合" class="hash-link" aria-label="使用 for 遍历集合的直接链接" title="使用 for 遍历集合的直接链接">​</a></h3><p>可以使用 <code>while</code> 结构来遍历集合中的元素，比如数组。</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let mut index = 0;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let a = [10, 20, 30, 40, 50];</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    while index &lt; 5 {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        println!("The value is: {}", a[index]);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        index += 1;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在这里，代码对数组中的元素进行计数。它从索引 0 开始，并接着循环直到遇到数组的最后一个索引（即 index &lt; 5 不再为真时）。运行这段代码会打印出数组中的每一个元素：</p><div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">PS E:\github\rust-projects\loops&gt; cargo run</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">   Compiling loops v0.1.0 (E:\github\rust-projects\loops)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    Finished dev [unoptimized + debuginfo] target(s) in 0.48s</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">     Running </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`target\debug\loops.exe`</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">The value is: 10</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">The value is: 20</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">The value is: 30</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">The value is: 40</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">The value is: 50</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>数组中的 5 个元素全部都如期被打印出来。尽管 <code>index</code> 在某一时刻会到达值 <code>5</code>，不过循环在其尝试从数组获取第 6 个值（会越界）之前就停止了。</p><p>但是这个过程很容易出错；如果索引值或测试条件不正确会导致程序 panic。例如，如果将 a 数组的定义更改为包含 4 个元素，但忘记将条件更新为 <code>while index &lt; 4</code>，则代码会出现 panic。这也使程序更慢，因为编译器增加了运行时代码来对每次循环进行条件检查，以确定在循环的每次迭代中索引是否在数组的边界内。</p><p>作为更简洁的替代方案，可以使用 <code>for</code> 循环来对一个集合的每个元素执行一些代码。<code>for</code> 循环看起来如下示例:</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let a = [10, 20, 30, 40, 50];</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    for element in a {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        println!("The value is: {}", element);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>当运行这段代码时，其结果与使用 <code>while</code> 实现的示例一样。更为重要的是，我们增强了代码安全性，并消除了可能由于超出数组的结尾或遍历长度不够而缺少一些元素而导致的 bug。</p><p>使用 <code>for</code> 循环的话，就不需要惦记着在改变数组元素个数时修改其他的代码了，就像使用上述示例中使用的方法一样。</p><p><code>for</code> 循环的安全性和简洁性使得它成为 Rust 中使用最多的循环结构。即使是在想要循环执行代码特定次数时，大部分也会倾向于使用 <code>for</code> 循环实现。</p><p>下面是一个使用 <code>for</code> 循环来倒计时的例子，它还使用了一个我们还未讲到的方法，<code>rev</code> 用来反转区间:</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    for element in (1..4).rev() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        println!("The value is: {}", element);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>输出结果:</p><div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">PS E:\github\rust-projects\loops&gt; cargo run</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">   Compiling loops v0.1.0 (E:\github\rust-projects\loops)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    Finished dev [unoptimized + debuginfo] target(s) in 0.55s</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">     Running </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`target\debug\loops.exe`</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">The value is: 3</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">The value is: 2</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">The value is: 1</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="练习">练习<a href="#练习" class="hash-link" aria-label="练习的直接链接" title="练习的直接链接">​</a></h2><ol><li><p><code>n</code> 阶段斐波那契数列</p><details class="details_lb9f alert alert--info details_b_Ee" data-collapsed="true"><summary>点击查看实现</summary><div><div class="collapsibleContent_i85q">思路:<p>F(0)=1，F(1)=1，F(n)=F(n-1)+F(n-2)（n≥2，n∈N<!-- -->*<!-- -->）</p><p>代码:</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn fibonacci_sequence(n: i32) -&gt; i32 {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    if n == 1 {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        return 1;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    } else if n == 2 {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        return 1;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        return fibonacci_sequence(n - 1) + fibonacci_sequence(n - 2);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div></div></details></li><li><p>华氏温度和摄氏度之间转换</p><details class="details_lb9f alert alert--info details_b_Ee" data-collapsed="true"><summary>点击查看实现</summary><div><div class="collapsibleContent_i85q">思路:<p>华氏温度和摄氏度之间的温度转换公式如下：</p><p>将摄氏度转换为华氏温度：
F = C <!-- -->*<!-- --> 9/5 + 32</p><p>其中，F 代表华氏温度，C 代表摄氏度。</p><p>将华氏温度转换为摄氏度：
C = (F - 32) <!-- -->*<!-- --> 5/9</p><p>其中，F 代表华氏温度，C 代表摄氏度。</p><p>例如：如果一个物体的温度是 37 摄氏度，那么用上述的转换公式可以计算出它对应的华氏温度为 37<!-- -->*<!-- -->9/5+32=98.6 度。</p><p>代码实现:</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let degrees: f64 = 37.0;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    println!(</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        "The fahrenheit of {} is: {}",</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        degrees,</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        degrees_to_fahrenheit(degrees)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    );</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let fahrenheit: f64 = 98.6;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    println!(</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        "The fahrenheit of {} is: {}",</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        fahrenheit,</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        fahrenheit_to_degrees(fahrenheit)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    );</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">// 摄氏度转华氏度</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn degrees_to_fahrenheit(degrees: f64) -&gt; f64 {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    return degrees * 9.0 / 5.0 + 32.0;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">// 华氏度转摄氏度</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn fahrenheit_to_degrees(fahrenheit: f64) -&gt; f64 {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    return (fahrenheit - 32.0) * (5.0 / 9.0);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div></div></details></li></ol>]]></content>
        <author>
            <name>Hanbin Che</name>
            <uri>https://github.com/hbche</uri>
        </author>
        <category label="rust" term="rust"/>
        <category label="控制流" term="控制流"/>
        <category label="通用编程概念" term="通用编程概念"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[IEEE-754标准]]></title>
        <id>https://hbche.github.io/my-website/blog/2023/10/08/ieee-754</id>
        <link href="https://hbche.github.io/my-website/blog/2023/10/08/ieee-754"/>
        <updated>2023-10-08T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[记录计算机组成原理学习过程]]></summary>
        <content type="html"><![CDATA[<p>IEEE 754 是一个由电子电气工程师协会（Institute of Electrical and Electronics Engineers，简称 IEEE）制定的标准，用于定义浮点数的表示和运算规则。这个标准定义了浮点数的二进制表示方式、运算规则和精度等重要内容，广泛应用于计算机科学和工程领域，以确保浮点数在不同计算平台上的一致性和可移植性。</p><p>IEEE 754 标准通常包括以下几个方面的内容：</p><ol><li><p><strong>浮点数格式</strong>：IEEE 754 定义了多种浮点数格式，包括单精度（32 位）、双精度（64 位）和拓展精度格式，它们都具有固定的位数用于表示符号、指数和尾数（也称为尾数、尾数位数），以及规定了如何将二进制位解释为实际的浮点数值。</p></li><li><p><strong>特殊值</strong>：IEEE 754 标准还定义了特殊值，如正无穷大、负无穷大、NaN（非数值）等，以处理在浮点数运算中可能出现的异常情况。</p></li><li><p><strong>浮点数运算</strong>：标准规定了浮点数的四则运算（加法、减法、乘法和除法）和取余等操作的规则，包括舍入规则和溢出处理方式。</p></li><li><p><strong>精度</strong>：IEEE 754 标准定义了浮点数的精度和有效位数，以及舍入方式，以确保在不同计算平台上的一致性。</p></li><li><p><strong>转换</strong>：标准还定义了浮点数和整数之间的相互转换规则。</p></li><li><p><strong>语言支持</strong>：IEEE 754 标准被广泛支持和实现在各种编程语言和硬件平台中，包括 C、C++、Java、Python 等，以及 CPU、GPU 和 FPGA 等硬件平台。</p></li></ol><p>IEEE 754 标准的主要目标是提供一种通用的浮点数表示和运算方式，以便不同计算平台上的程序能够以一致的方式处理浮点数。然而，由于浮点数运算的特殊性质，开发人员需要了解标准中的一些细节，以避免由于舍入误差和浮点数精度问题而导致的潜在问题。在编写需要高精度浮点数运算的应用程序时，可能需要额外的精度控制和数值分析技巧。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="浮点数格式">浮点数格式<a href="#浮点数格式" class="hash-link" aria-label="浮点数格式的直接链接" title="浮点数格式的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="单精度浮点数">单精度浮点数<a href="#单精度浮点数" class="hash-link" aria-label="单精度浮点数的直接链接" title="单精度浮点数的直接链接">​</a></h3><p>IEEE 754 标准定义了多种浮点数格式，包括单精度浮点数（Single Precision Floating-Point）。单精度浮点数使用 32 位二进制位来表示一个浮点数，其中包括一个符号位、一个指数位和剩余的尾数位。</p><p>以下是单精度浮点数的一般结构：</p><ul><li>符号位（1 位）：指示浮点数的正负。0 表示正数，1 表示负数。</li><li>指数位（8 位）：表示指数的偏移值，通常采用偏移表示法。这意味着存储的指数值必须减去一个偏移值，以得到实际的指数。这允许表示一定范围的指数值。</li><li>尾数位（23 位）：也称为尾数或尾数位数，用于存储浮点数的小数部分。</li></ul><p>单精度浮点数的指数部分可以表示从 -126 到 127 的指数范围，因此它可以表示非常大和非常小的浮点数。</p><p>单精度浮点数遵循 IEEE 754 标准定义的浮点数运算规则，包括加法、减法、乘法、除法以及处理特殊值（如无穷大和 NaN）的规则。单精度浮点数通常用于需要较小存储空间或需要较快运算速度的应用程序中。</p><p>在 C 语言中，单精度浮点数通常使用<code>float</code>类型来表示。例如：</p><div class="language-c codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">float</span><span class="token plain"> myFloat </span><span class="token operator">=</span><span class="token plain"> </span><span class="token number">3.14f</span><span class="token punctuation" style="color:rgb(248, 248, 242)">;</span><span class="token plain">  </span><span class="token comment" style="color:rgb(98, 114, 164)">// 使用f后缀表示单精度浮点数</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在许多编程语言中，包括 C、C++、Java 等，可以使用单精度浮点数进行科学计算、图形处理和其他需要高性能浮点数运算的领域。但需要注意，单精度浮点数通常比双精度浮点数精度低，因此在需要更高精度的应用程序中，可能需要使用双精度浮点数。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="双精度浮点数">双精度浮点数<a href="#双精度浮点数" class="hash-link" aria-label="双精度浮点数的直接链接" title="双精度浮点数的直接链接">​</a></h3><p>IEEE 754 标准定义了双精度浮点数（Double Precision Floating-Point），它是一种用于表示浮点数的二进制格式，提供更高的精度和范围，相对于单精度浮点数而言。</p><p>以下是双精度浮点数的一般结构：</p><ul><li>符号位（1 位）：指示浮点数的正负。0 表示正数，1 表示负数。</li><li>指数位（11 位）：表示指数的偏移值，通常采用偏移表示法。这意味着存储的指数值必须减去一个偏移值，以得到实际的指数。这允许表示更大范围的指数值。</li><li>尾数位（52 位）：也称为尾数或尾数位数，用于存储浮点数的小数部分。</li></ul><p>双精度浮点数的指数部分可以表示从 -1022 到 1023 的指数范围，因此它可以表示非常大和非常小的浮点数，并且具有更高的精度，相对于单精度浮点数。</p><p>双精度浮点数遵循 IEEE 754 标准定义的浮点数运算规则，包括加法、减法、乘法、除法以及处理特殊值（如无穷大和 NaN）的规则。</p><p>在 C 语言中，双精度浮点数通常使用 <code>double</code> 类型来表示。例如：</p><div class="language-c codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">double</span><span class="token plain"> myDouble </span><span class="token operator">=</span><span class="token plain"> </span><span class="token number">3.141592653589793</span><span class="token punctuation" style="color:rgb(248, 248, 242)">;</span><span class="token plain">  </span><span class="token comment" style="color:rgb(98, 114, 164)">// 双精度浮点数</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在许多编程语言中，包括 C、C++、Java 等，双精度浮点数是默认的浮点数类型，因为它提供了较高的精度，适用于科学计算、工程应用、图形处理和其他需要高精度浮点数运算的领域。但请注意，浮点数运算仍然可能涉及到精度误差和舍入误差，因此在进行浮点数计算时需要谨慎处理。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="浮点数运算">浮点数运算<a href="#浮点数运算" class="hash-link" aria-label="浮点数运算的直接链接" title="浮点数运算的直接链接">​</a></h2><p>IEEE 754 标准定义了浮点数的运算规则，包括加法、减法、乘法、除法以及处理特殊值（如无穷大和 NaN）的规则。这些规则旨在确保在不同计算平台上执行相同的浮点数运算时，能够获得一致的结果。以下是 IEEE 754 浮点数运算的一些关键规则：</p><ol><li><p><strong>加法和减法</strong>：</p><ul><li>对于两个浮点数的加法和减法，首先需要比较它们的指数部分，将指数较小的数进行指数对齐，然后将尾数相加或相减。</li><li>在进行加法和减法运算后，需要对结果进行舍入，以将其规范化为 IEEE 754 标准中的格式。</li></ul></li><li><p><strong>乘法</strong>：</p><ul><li>乘法运算涉及将两个浮点数的尾数相乘，并将指数相加。</li><li>乘法运算后，需要对结果进行舍入，以将其规范化。</li></ul></li><li><p><strong>除法</strong>：</p><ul><li>除法运算涉及将两个浮点数的尾数相除，并将指数相减。</li><li>除法运算后，需要对结果进行舍入，以将其规范化。</li></ul></li><li><p><strong>特殊值的处理</strong>：</p><ul><li>IEEE 754 标准定义了一些特殊的浮点数值，如正无穷大、负无穷大、NaN（非数值）等。这些特殊值的运算规则也在标准中定义，以确保一致性和安全性。</li></ul></li><li><p><strong>舍入规则</strong>：</p><ul><li>IEEE 754 标准定义了多种舍入模式，包括向最接近的偶数舍入、向零舍入、向正无穷大舍入、向负无穷大舍入等。程序员可以根据需要选择适当的舍入模式。</li></ul></li><li><p><strong>精度和溢出</strong>：</p><ul><li>标准还规定了浮点数的精度要求，以及如何处理溢出情况。</li></ul></li></ol><p>需要注意的是，浮点数运算可能会引入舍入误差，特别是在大范围的值或极小的值上。因此，在进行浮点数运算时，程序员应该谨慎处理，避免依赖于精确的比较。此外，一些浮点数运算可能会导致不稳定的行为，特别是在数值分析中。</p><p>总之，IEEE 754 浮点数运算规则是确保浮点数在计算机上进行一致和可预测运算的关键标准，但在实际应用中需要了解其局限性和可能引入的误差。</p>]]></content>
        <author>
            <name>Hanbin Che</name>
            <uri>https://github.com/hbche</uri>
        </author>
        <category label="标准" term="标准"/>
        <category label="计算机" term="计算机"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Rust 通用编程概念 - 数据类型]]></title>
        <id>https://hbche.github.io/my-website/blog/2023/10/08/rust-data-type</id>
        <link href="https://hbche.github.io/my-website/blog/2023/10/08/rust-data-type"/>
        <updated>2023-10-08T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[记录 Rust 学习过程]]></summary>
        <content type="html"><![CDATA[<p>Rust 是一种<strong>静态类型</strong>(statically typed)的语言，这意味着它必须在编译期间就要知道所有变量的类型。编译器通常可以根据值和使用方式推导出我们想要使用的类型。在类型可能是多种情况时，例如我们使用 <code>parse</code> 将 <code>String</code> 转换成数值类型时，必须加上一个类型标注：</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">let guess: u32 = "42".parse().expect("Not a number");</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>如果不添加类型标注的话，Rust 将显示如下错误</p><div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">error</span><span class="token url-reference url punctuation" style="color:rgb(248, 248, 242)">[</span><span class="token url-reference url variable" style="color:rgb(189, 147, 249);font-style:italic">E0282</span><span class="token url-reference url punctuation" style="color:rgb(248, 248, 242)">]</span><span class="token url-reference url punctuation" style="color:rgb(248, 248, 242)">:</span><span class="token url-reference url"> type</span><span class="token plain"> annotations needed</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"> --&gt; src\main.rs:2:9</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">2 |     let guess = "42".parse().expect("Not a number");</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |         ^^^^^</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">help: consider giving </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`guess`</span><span class="token plain"> an explicit type</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">2 |     let guess: /</span><span class="token italic punctuation" style="color:rgb(248, 248, 242)">*</span><span class="token italic content"> Type </span><span class="token italic punctuation" style="color:rgb(248, 248, 242)">*</span><span class="token plain">/ = "42".parse().expect("Not a number");</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |              ++++++++++++</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">For more information about this error, try </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`rustc --explain E0282`</span><span class="token plain">.</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">error: could not compile </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`guessing`</span><span class="token plain"> (bin "guessing") due to previous error</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>帮助信息中给出了修改建议 <code>consider giving 'guess' an explicit type</code>[考虑给 guess 一个明确的类型]</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="标量类型">标量类型<a href="#标量类型" class="hash-link" aria-label="标量类型的直接链接" title="标量类型的直接链接">​</a></h2><p>标量（scalar）类型表示单个值。Rust 有 4 个基本的标量类型：整型、浮点型、布尔型和字符。你可能从其他语言了解过这些类型。下面我们深入了解它们在 Rust 中的用法。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="整数类型">整数类型<a href="#整数类型" class="hash-link" aria-label="整数类型的直接链接" title="整数类型的直接链接">​</a></h3><p>整数（integer）是没有小数部分的数字。例如 <code>u32</code>，此类型声明表明它关联的值应该是占用 32 位空间的无符号整型（有符号整型以 i 开始，i 是英文单词 integer 的首字母，与之相反的是 u，代表无符号 unsigned 类型）。下表显示了 Rust 中内置的整数类型。我们可以使用这些定义形式中的任何一个来声明整数值的类型。</p><table><thead><tr><th>长度</th><th>有符号类型</th><th>无符号类型</th></tr></thead><tbody><tr><td>8 位</td><td>i8</td><td>u8</td></tr><tr><td>16 位</td><td>i16</td><td>u16</td></tr><tr><td>32 位</td><td>i32</td><td>u32</td></tr><tr><td>64 位</td><td>i64</td><td>u64</td></tr><tr><td>128 位</td><td>i128</td><td>u128</td></tr><tr><td>arch</td><td>isize</td><td>usize</td></tr></tbody></table><p>有符号和无符号表示数字能否取负数——也就是说，这个数是否可能是负数（有符号类型），或一直为正而不需要带上符号（无符号类型）。</p><p>每个有符号类型规定的数字范围是 -(2n - 1) ~ 2n - 1 - 1，其中 n 是该定义形式的位长度。所以 i8 可存储数字范围是 -(27) ~ 27 - 1，即 -128 ~ 127。无符号类型可以存储的数字范围是 0 ~ 2n - 1，所以 u8 能够存储的数字为 0 ~ 28 - 1，即 0 ~ 255。</p><p>此外，<code>isize</code> 和 <code>usize</code> 类型取决于程序运行的计算机体系结构，在表中表示为“arch”：若使用 64 位架构系统则为 64 位，若使用 32 位架构系统则为 32 位。</p><p>可按下表中所示的任意形式来编写整型的字面量。注意，可能属于多种数字类型的数字字面量允许使用类型后缀来指定类型，例如 <code>57u8</code>。数字字面量还可以使用 <code>_</code> 作为可视分隔符以方便读数，如 <code>1_000</code>，此值和 <code>1000</code> 相同。</p><table><thead><tr><th>数字字面量</th><th>示例</th></tr></thead><tbody><tr><td>十进制</td><td><code>98_222</code></td></tr><tr><td>十六进制</td><td><code>0xff</code></td></tr><tr><td>八进制</td><td><code>0o77</code></td></tr><tr><td>二进制</td><td><code>0b1111_0000</code></td></tr><tr><td>字节 (仅限于 <code>u8</code>)</td><td><code>b'A'</code></td></tr></tbody></table><p>那么该使用哪种类型的整型呢？如果不确定，<strong>Rust 的默认形式通常是个不错的选择，整型默认是 <code>i32</code></strong>。<code>isize</code> 和 <code>usize</code> 的主要应用场景是用作某些集合的索引。</p><div class="theme-admonition theme-admonition-caution alert alert--warning admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"></path></svg></span>警告</div><div class="admonitionContent_S0QG"><h4 class="anchor anchorWithStickyNavbar_LWe7" id="整型溢出">整型溢出<a href="#整型溢出" class="hash-link" aria-label="整型溢出的直接链接" title="整型溢出的直接链接">​</a></h4><p>比方说有一个 <code>u8</code> 类型的变量 ，它可以存放从 <code>0</code> 到 <code>255</code> 的值。那么当你将其修改为范围之外的值，比如 <code>256</code>，则会发生<strong>整型溢出</strong>（integer overflow），这会导致两种行为的其中一种。当在调试（debug）模式编译时，Rust 会检查整型溢出，若存在这些问题则使程序在编译时 panic。Rust 使用 panic 这个术语来表明程序因错误而退出。</p><p>在当使用 --release 参数进行发布（release）模式构建时，Rust <strong>不</strong>检测会导致 panic 的整型溢出。相反当检测到整型溢出时，Rust 会进行一种被称为二进制补码包裹（two’s complement wrapping）的操作。简而言之，大于该类型最大值的数值会被“包裹”成该类型能够支持的对应数字的最小值。比如在 u8 的情况下，256 变成 0，257 变成 1，依此类推。程序不会 <code>panic</code>，但是该变量的值可能不是你期望的值。依赖整型溢出包裹的行为不是一种正确的做法。</p><p>要显式处理溢出的可能性，可以使用标准库针对原始数字类型提供的以下一系列方法：</p><ul><li>使用 <code>wrapping_*</code> 方法在所有模式下进行包裹，例如 wrapping_add</li><li>如果使用 <code>checked_*</code> 方法时发生溢出，则返回 None 值</li><li>使用 <code>overflowing_*</code> 方法返回该值和一个指示是否存在溢出的布尔值</li><li>使用 <code>saturating_*</code> 方法使值达到最小值或最大值</li></ul></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="浮点类型">浮点类型<a href="#浮点类型" class="hash-link" aria-label="浮点类型的直接链接" title="浮点类型的直接链接">​</a></h3><p><strong>浮点数</strong>（floating-point number）是带有小数点的数字，在 Rust 中浮点类型（简称浮点型）数字也有两种基本类型。Rust 的浮点型是 <code>f32</code> 和 <code>f64</code>，它们的大小分别为 <code>32</code> 位和 <code>64</code> 位。默认浮点类型是 <code>f64</code>，因为在现代的 CPU 中它的速度与 <code>f32</code> 的几乎相同，但精度更高。<strong>所有浮点型都是有符号的。</strong></p><p>下面是一个演示浮点数的示例:</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let x = 2.0; // f64</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    ley y: f32 = 3.0; // f32</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>浮点数按照 IEEE-754 标准表示。<code>f32</code> 类型是单精度浮点型，<code>f64</code> 为双精度浮点型。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="数字运算">数字运算<a href="#数字运算" class="hash-link" aria-label="数字运算的直接链接" title="数字运算的直接链接">​</a></h3><p>Rust 的所有数字类型都支持基本数学运算：加法、减法、乘法、除法和取模运算。<strong>整数除法会向下取整。</strong>下面代码演示了各使用一条 let 语句来说明相应数字运算的用法：</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let sum = 5 + 10;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let difference = 95.5 - 4.3;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let product = 4 * 30;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let quotient = 56.7 / 32.2;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let floored = 2 / 3; // Results in 0</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let remainder = 43 % 5;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    println!(</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        "sum: {}, difference: {}, product: {}, quotient: {}, floored: {}, remainder: {}",</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        sum, difference, product, quotient, floored, remainder</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    );</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>输出:</p><div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">sum: 15, difference: 91.2, product: 120, quotient: 1.7608695652173911, floored: 0, remainder: 3</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="布尔类型">布尔类型<a href="#布尔类型" class="hash-link" aria-label="布尔类型的直接链接" title="布尔类型的直接链接">​</a></h3><p>和大多数编程语言一样，Rust 中的布尔类型也有两个可能的值：<code>true</code> 和 <code>false</code>。布尔值的大小为 1 个字节。Rust 中的布尔类型使用 <code>bool</code> 声明。例如：</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let t = true;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let f: bool = false;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="字符类型">字符类型<a href="#字符类型" class="hash-link" aria-label="字符类型的直接链接" title="字符类型的直接链接">​</a></h3><p>Rust 的 <code>char</code>（字符）类型是该语言最基本的字母类型，下面是一些声明 <code>char</code> 值的例子：</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let c = 'z';</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let z = 'ℤ';</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let heart_eyed_cat = '😻';</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    println!("c: {}, z: {}, heart_eyed_cat: {}", c, z, heart_eyed_cat);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>输出:</p><div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">country: z, province: ℤ, heart_eyed_cat: 😻</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><div class="theme-admonition theme-admonition-caution alert alert--warning admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"></path></svg></span>警告</div><div class="admonitionContent_S0QG"><p>注意，我们声明的 <code>char</code> 字面量采用单引号括起来 <!-- -->[双引号也可以]<!-- -->，这与 <strong>字符串</strong> 字面量不同，字符串字面量是用双引号括起来。Rust 的字符类型大小为 4 个字节，表示的是一个 Unicode 标量值，这意味着它可以表示的远远不止是 ASCII。标音字母，中文/日文/韩文的文字，emoji，还有零宽空格(zero width space)在 Rust 中都是合法的字符类型。Unicode 值的范围为 <code>U+0000 ~ U+D7FF</code> 和 <code>U+E000~U+10FFFF</code>。不过“字符”并不是 Unicode 中的一个概念，所以人在直觉上对“字符”的理解和 Rust 的字符概念并不一致。</p></div></div><p>字符串示例:</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let country = "China";</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let province = "Hubei";</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let heart_eyed_cat = "😻";</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    println!(</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        "country: {}, province: {}, heart_eyed_cat: {}",</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        country, province, heart_eyed_cat</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    );</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>输出:</p><div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">country: China, province: Hubei, heart_eyed_cat: 😻</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><div class="theme-admonition theme-admonition-caution alert alert--warning admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"></path></svg></span>警告</div><div class="admonitionContent_S0QG"><p>字符串常量只能使用双引号<code>"</code>包裹，不能用单引号<code>'</code>包裹，否则 Rust 编译器会报错。</p><div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">error: character literal may only contain one codepoint</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"> --&gt; src\main.rs:2:19</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">2 |     let country = 'China';</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |                   ^^^^^^^</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">help: if you meant to write a </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`str`</span><span class="token plain"> literal, use double quotes</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">2 |     let country = "China";</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |                   ~~~~~</span><span class="token strike punctuation" style="color:rgb(248, 248, 242)">~~</span><span class="token strike content"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token strike content">error: character literal may only contain one codepoint</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token strike content"> --&gt; src\main.rs:3:20</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token strike content">  |</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token strike content">3 |     let province = 'Hubei';</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token strike content">  |                    ^^^^^^^</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token strike content">  |</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token strike content">help: if you meant to write a </span><span class="token strike content code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`str`</span><span class="token strike content"> literal, use double quotes</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token strike content">  |</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token strike content">3 |     let province = "Hubei";</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token strike content">  |                    </span><span class="token strike punctuation" style="color:rgb(248, 248, 242)">~~</span><span class="token plain">~~~~~</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">error: could not compile </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`guessing`</span><span class="token plain"> (bin "guessing") due to 2 previous errors</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述提示中 <code>if you meant to write a 'str' literal, use double quotes</code> 已经给出了很明确的提示了 <code>如果你想写一个' str '字面值，请使用双引号</code>，并给出了正确的格式。</p></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="复合类型">复合类型<a href="#复合类型" class="hash-link" aria-label="复合类型的直接链接" title="复合类型的直接链接">​</a></h2><p><strong>复合类型</strong>（compound type）可以将多个值组合成一个类型。Rust 有两种基本的复合类型：元组（tuple）和数组（array）。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="元组类型">元组类型<a href="#元组类型" class="hash-link" aria-label="元组类型的直接链接" title="元组类型的直接链接">​</a></h3><p>元组是将多种类型的多个值组合到一个复合类型中的一种基本方式。元组的长度是固定的：声明后，它们就无法增长或缩小。</p><p>我们通过在小括号内写入以逗号分隔的值列表来创建一个元组。元组中的每个位置都有一个类型，并且元组中不同值的类型不要求是相同的。我们在下面示例中添加了可选的类型标注：</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let tup: (i32, f64, u8) = (500, 6.4, 1);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>变量 tup 绑定到整个元组，因为元组被认作是单个复合元素。 想从元组中获取个别值，我们可以使用模式匹配来解构（destructure）元组的一个值，如下所示：</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let tup: (i32, f64, u8) = (500, 6.4, 1);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let (x, y, z) = tup;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    println!("The value of tup is: ({}, {}, {})", x, y, z);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>输出:</p><div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">The value of tup is: (500, 6.4, 1)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>该程序首先创建一个元组并将其绑定到变量 tup 上。 然后它借助 let 来使用一个模式匹配 tup，并将它分解成三个单独的变量 x、y 和 z。 这过程称为解构（destructuring），因为它将单个元组分为三部分。最后，程序打印出 y 值，为 6.4。</p><p>除了通过模式匹配进行解构外，我们还可以使用一个句点（.）连上要访问的值的索引来直接访问元组元素。例如：</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let tup: (i32, f64, u8) = (500, 6.4, 1);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    println!("The value of tup is: ({}, {}, {})", tup.0, tup.1, tup.2);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>输出:</p><div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">The value of tup is: (500, 6.4, 1)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>和大多数编程语言一样，元组中的第一个索引为 0。</p><p>没有任何值的元组 () 是一种特殊的类型，只有一个值，也写成 ()。该类型被称为单元类型（unit type），该值被称为单元值（unit value）。如果表达式不返回任何其他值，就隐式地返回单元值。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="数组类型">数组类型<a href="#数组类型" class="hash-link" aria-label="数组类型的直接链接" title="数组类型的直接链接">​</a></h3><p>将多个值组合在一起的另一种方式就是使用数组（array）。与元组不同，数组的每个元素必须具有相同的类型。与某些其他语言中的数组不同，Rust 中的数组具有固定长度。</p><p>我们在方括号内以逗号分隔的列表形式将值写到数组中：</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let a = [1, 2, 3, 4, 5];</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>当你希望将数据分配到栈（stack）而不是堆（heap）时，或者当你希望确保始终具有固定数量的元素时，数组特别有用。但它们不像 vector（译注：中文字面翻译为“向量”，在 Rust 中意义为“动态数组，可变数组”）类型那么灵活。vector 类型类似于标准库中提供的集合类型，其大小允许增长或缩小。如果不确定是使用数组还是 vector，那就应该使用一个 vector。</p><p>不过当你明确元素数量不需要改变时，数组会更有用。例如，如果你在程序中使用月份的名称，你很可能希望使用的是数组而不是 vector，因为你知道它始终包含 12 个元素：</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">let months = ["January", "February", "March", "April", "May", "June", "July",</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">              "August", "September", "October", "November", "December"];</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>使用方括号编写数组的类型，其中包含每个元素的类型、分号，然后是数组中的元素数，如下所示：</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">let a: [i32; 5] = [1, 2, 3, 4, 5];</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这里，<code>i32</code> 是每个元素的类型。分号之后，数字 <code>5</code> 表明该数组包含 5 个元素。</p><p>以这种方式编写数组的类型看起来类似于初始化数组的另一种语法：如果要为每个元素创建包含相同值的数组，可以指定初始值，后跟分号，然后在方括号中指定数组的长度，如下所示：</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let a: [i32; 5] = [3; 5];</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    println!(</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        "The value of a is: [{}, {}, {}, {}, {}]",</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        a[0], a[1], a[2], a[3], a[4]</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    );</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>变量名为 <code>a</code> 的数组将包含 <code>5</code> 个元素，这些元素的值初始化为 <code>3</code>。这种写法与 <code>let a = [3, 3, 3, 3, 3];</code> 效果相同，但更简洁。</p><div class="theme-admonition theme-admonition-caution alert alert--warning admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"></path></svg></span>警告</div><div class="admonitionContent_S0QG"><h4 class="anchor anchorWithStickyNavbar_LWe7" id="元组索引-vs-数组索引">元组索引 vs 数组索引<a href="#元组索引-vs-数组索引" class="hash-link" aria-label="元组索引 vs 数组索引的直接链接" title="元组索引 vs 数组索引的直接链接">​</a></h4><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let a = [3; 5];</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    println!(</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        "The value of a is: [{}, {}, {}, {}, {}]",</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        a.0, a.1, a.2, a.3, a.4</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    );</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>如果上述数组使用的是点号引用指定索引的数据，将会报如下错误:</p><div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">error</span><span class="token url-reference url punctuation" style="color:rgb(248, 248, 242)">[</span><span class="token url-reference url variable" style="color:rgb(189, 147, 249);font-style:italic">E0609</span><span class="token url-reference url punctuation" style="color:rgb(248, 248, 242)">]</span><span class="token url-reference url punctuation" style="color:rgb(248, 248, 242)">:</span><span class="token url-reference url"> no</span><span class="token plain"> field </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`0`</span><span class="token plain"> on type </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`[{integer}; 5]`</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"> --&gt; src\main.rs:5:11</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">5 |         a.0, a.1, a.2, a.3, a.4</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |         --^</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |         |</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |         help: instead of using tuple indexing, use array indexing: </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`a[0]`</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">error</span><span class="token url-reference url punctuation" style="color:rgb(248, 248, 242)">[</span><span class="token url-reference url variable" style="color:rgb(189, 147, 249);font-style:italic">E0609</span><span class="token url-reference url punctuation" style="color:rgb(248, 248, 242)">]</span><span class="token url-reference url punctuation" style="color:rgb(248, 248, 242)">:</span><span class="token url-reference url"> no</span><span class="token plain"> field </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`1`</span><span class="token plain"> on type </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`[{integer}; 5]`</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"> --&gt; src\main.rs:5:16</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">5 |         a.0, a.1, a.2, a.3, a.4</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |              --^</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |              |</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |              help: instead of using tuple indexing, use array indexing: </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`a[1]`</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">error</span><span class="token url-reference url punctuation" style="color:rgb(248, 248, 242)">[</span><span class="token url-reference url variable" style="color:rgb(189, 147, 249);font-style:italic">E0609</span><span class="token url-reference url punctuation" style="color:rgb(248, 248, 242)">]</span><span class="token url-reference url punctuation" style="color:rgb(248, 248, 242)">:</span><span class="token url-reference url"> no</span><span class="token plain"> field </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`2`</span><span class="token plain"> on type </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`[{integer}; 5]`</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"> --&gt; src\main.rs:5:21</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">5 |         a.0, a.1, a.2, a.3, a.4</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |                   --^</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |                   |</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |                   help: instead of using tuple indexing, use array indexing: </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`a[2]`</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">error</span><span class="token url-reference url punctuation" style="color:rgb(248, 248, 242)">[</span><span class="token url-reference url variable" style="color:rgb(189, 147, 249);font-style:italic">E0609</span><span class="token url-reference url punctuation" style="color:rgb(248, 248, 242)">]</span><span class="token url-reference url punctuation" style="color:rgb(248, 248, 242)">:</span><span class="token url-reference url"> no</span><span class="token plain"> field </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`3`</span><span class="token plain"> on type </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`[{integer}; 5]`</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"> --&gt; src\main.rs:5:26</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">5 |         a.0, a.1, a.2, a.3, a.4</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |                        |</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |                        help: instead of using tuple indexing, use array indexing: </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`a[3]`</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">error</span><span class="token url-reference url punctuation" style="color:rgb(248, 248, 242)">[</span><span class="token url-reference url variable" style="color:rgb(189, 147, 249);font-style:italic">E0609</span><span class="token url-reference url punctuation" style="color:rgb(248, 248, 242)">]</span><span class="token url-reference url punctuation" style="color:rgb(248, 248, 242)">:</span><span class="token url-reference url"> no</span><span class="token plain"> field </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`4`</span><span class="token plain"> on type </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`[{integer}; 5]`</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"> --&gt; src\main.rs:5:31</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">5 |         a.0, a.1, a.2, a.3, a.4</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |                             --^</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |                             |</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |                             help: instead of using tuple indexing, use array indexing: </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`a[4]`</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">For more information about this error, try </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`rustc --explain E0609`</span><span class="token plain">.</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">error: could not compile </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`guessing`</span><span class="token plain"> (bin "guessing") due to 5 previous errors</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>帮助提示给的也很清晰，提示我们使用数组索引 <code>a[0]</code> 替换元组索引 <code>a.0</code>。</p></div></div><h4 class="anchor anchorWithStickyNavbar_LWe7" id="访问数组元素">访问数组元素<a href="#访问数组元素" class="hash-link" aria-label="访问数组元素的直接链接" title="访问数组元素的直接链接">​</a></h4><p>数组是可以在栈上分配的已知固定大小的单个内存块。可以使用索引访问数组的元素，如下所示：</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let a = [1, 2, 3, 4, 5];</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let first = a[0];</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let second = a[1];</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在这个例子中，名为 <code>first</code> 的变量将获得值 <code>1</code>，因为它是数组中索引 <code>[0]</code> 处的值。名为 second 的变量将从数组中的索引 <code>[1]</code> 中获取得 <code>2</code>。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="无效的数组元素访问">无效的数组元素访问<a href="#无效的数组元素访问" class="hash-link" aria-label="无效的数组元素访问的直接链接" title="无效的数组元素访问的直接链接">​</a></h4><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">use std::io;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let a = [1, 3, 5, 7, 9];</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    println!("Please enter an array index.");</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let mut index = String::new();</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    io::stdin()</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        .read_line(&amp;mut index)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        .expect("Failed to read line");</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let index: usize = index</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        .trim()</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        .parse()</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        .expect("Index entered was not a number");</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let element = a[index];</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    println!(</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        "The value of the element at index {} is: {}",</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        index, element</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    );</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>此代码编译成功。如果使用 cargo run 来运行此代码并输入 0、1、2、3 或 4，则程序将打印数组对应索引的值。如果输入的是超出数组末尾的数字，例如 5，则会看到类似以下的输出：</p><div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">    Finished dev [unoptimized + debuginfo] target(s) in 0.02s</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">     Running </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`target\debug\guessing.exe`</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">Please enter an array index.</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">5</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 5', src\main.rs:16:19</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">note: run with </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`RUST_BACKTRACE=1`</span><span class="token plain"> environment variable to display a backtrace</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">error: process didn't exit successfully: </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`target\debug\guessing.exe`</span><span class="token plain"> (exit code: 101)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>该程序在索引操作中使用无效值时导致<strong>运行时</strong>（runtime）错误。程序退出并显示错误消息，未执行后面的 println! 语句。当你尝试使用索引访问元素时，Rust 将检查你指定的索引是否小于数组长度。如果索引大于或等于数组长度，Rust 会出现 <code>panic</code>。这种检查必须在运行时进行，尤其是在这种情况下，因为编译器可能无法知道用户之后运行代码时将输入什么值。</p><p>这是 Rust 在安全原则实践中的第一个例子。在很多低级语言中，并不进行这种检查，而且在你使用不正确的索引时，可以访问无效的内存。Rust 通过立即退出来的方式防止这种错误，而不是允许内存访问并继续运行程序。</p>]]></content>
        <author>
            <name>Hanbin Che</name>
            <uri>https://github.com/hbche</uri>
        </author>
        <category label="rust" term="rust"/>
        <category label="数据类型" term="数据类型"/>
        <category label="通用编程概念" term="通用编程概念"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Rust 通用编程概念 - 函数]]></title>
        <id>https://hbche.github.io/my-website/blog/2023/10/08/rust-function</id>
        <link href="https://hbche.github.io/my-website/blog/2023/10/08/rust-function"/>
        <updated>2023-10-08T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[记录 Rust 学习过程]]></summary>
        <content type="html"><![CDATA[<p>函数在 Rust 代码中很普遍。你已经见过语言中最重要的函数之一：<code>main</code> 函数，它是很多程序的入口点。你也见过 <code>fn</code> 关键字，它用来声明新函数。</p><p>Rust 代码中的函数和变量名使用下划线命名法（snake case，直译为蛇形命名法）规范风格。在下划线命名法中，所有字母都是小写并使用下划线分隔单词。这是一个包含函数定义示例的程序：</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    println!("Hello, world!");</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    another_function();</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn another_function() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    println!("Another function.");</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Rust 中的函数定义以 <code>fn</code> 开始，后跟着函数名和一对圆括号。大括号告诉编译器函数体在哪里开始和结束。</p><p>可以使用函数名后跟圆括号来调用我们定义过的任意函数。因为程序中已定义 <code>another_function</code> 函数，所以可以在 <code>main</code> 函数中调用它。注意，源码中 <code>another_function</code> 定义在 <code>main</code> 函数<strong>之后</strong>；也可以定义在之前。<strong>Rust 不关心函数定义于何处，只要定义了就行。</strong></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="参数">参数<a href="#参数" class="hash-link" aria-label="参数的直接链接" title="参数的直接链接">​</a></h3><p>函数也可以被定义为拥有参数（parameter），参数是特殊变量，是函数签名的一部分。当函数拥有参数（形参）时，可以为这些参数提供具体的值（实参）。技术上讲，这些具体值被称为实参（argument），但是在日常交流中，人们倾向于不区分使用 parameter 和 argument 来表示函数定义中的变量或调用函数时传入的具体值。当一个函数有多个参数时，使用逗号分隔。我们来看一下下面的示例:</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    println!("Hello, world!");</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    another_function(3, 4);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn another_function(x: i32, y: i32) {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    println!("The sum of x and y is: {}", x + y);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>输出结果:</p><div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">Hello, world!</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">The sum of a and b is: 7</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><code>another_function</code> 函数中声明了两个参数，分别命名为 <code>x</code> 和 <code>y</code>，并指定类型为 <code>i32</code>。当我们将 <code>3</code> 和 <code>4</code> 传给 <code>another_function</code> 函数时，<code>println!</code> 宏将 <code>x</code> 和 <code>y</code> 相加的和放入格式化字符串中大括号的位置。</p><p>在函数签名中，必须声明每个参数的类型。这是一个在 Rust 设计中经过慎重考虑的决定：要求在函数定义中提供类型标注，意味着编译器几乎从不需要你在代码的其他地方注明类型来指出你的意图。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="语句和表达式">语句和表达式<a href="#语句和表达式" class="hash-link" aria-label="语句和表达式的直接链接" title="语句和表达式的直接链接">​</a></h3><p>函数体由一系列语句组成，也可选择以表达式结尾。目前为止，我们介绍的函数还没有包含结尾表达式，不过你已经看到了表达式作为语句的一部分。因为 Rust 是一门基于表达式（expression-based）的语言，所以这是一个需要理解的重要区别。其他语言没有这样的区别，所以让我们看看语句和表达式分别是什么，以及它们的区别如何影响函数体。</p><p><strong>语句</strong>（statement）是执行一些操作但不返回值的指令。表达式（expression）计算并产生一个值。让我们看一些例子：</p><p>实际上，我们已经使用过语句和表达式。使用 <code>let</code> 关键字创建变量并绑定一个值是一个语句。例如，<code>let y = 6;</code> 是一个语句。</p><p>函数定义也是语句，上面整个例子本身就是一个语句。</p><p>语句不返回值。因此，不能把 <code>let</code> 语句赋值给另一个变量，就像下面的代码尝试做的那样，会产生一个错误：</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let x = (let y = 6);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>当运行这个程序时，会得到如下错误：</p><div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">   Compiling function-demo v0.1.0 (E:\github\rust-projects\function-demo)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">error: expected expression, found </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`let`</span><span class="token plain"> statement</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"> --&gt; src\main.rs:2:14</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">2 |     let x = (let y = 6);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |              ^^^</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">error: expected expression, found statement (</span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`let`</span><span class="token plain">)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"> --&gt; src\main.rs:2:14</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">2 |     let x = (let y = 6);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |              ^^^^^^^^^</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  = note: variable declaration using </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`let`</span><span class="token plain"> is a statement</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">error</span><span class="token url-reference url punctuation" style="color:rgb(248, 248, 242)">[</span><span class="token url-reference url variable" style="color:rgb(189, 147, 249);font-style:italic">E0658</span><span class="token url-reference url punctuation" style="color:rgb(248, 248, 242)">]</span><span class="token url-reference url punctuation" style="color:rgb(248, 248, 242)">:</span><span class="token url-reference url"> `let`</span><span class="token plain"> expressions in this position are unstable</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"> --&gt; src\main.rs:2:14</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">2 |     let x = (let y = 6);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |              ^^^^^^^^^</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  = note: see issue #53667 &lt;https://github.com/rust-lang/rust/issues/53667&gt; for more information</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">warning: unnecessary parentheses around assigned value</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"> --&gt; src\main.rs:2:13</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">2 |     let x = (let y = 6);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |             ^         ^</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  = note: </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`#[warn(unused_parens)]`</span><span class="token plain"> on by default</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">help: remove these parentheses</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">2 -     let x = (let y = 6);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">2 +     let x = let y = 6;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">For more information about this error, try </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`rustc --explain E0658`</span><span class="token plain">.</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">warning: </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`function-demo`</span><span class="token plain"> (bin "function-demo") generated 1 warning</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">error: could not compile </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`function-demo`</span><span class="token plain"> (bin "function-demo") due to 3 previous errors; 1 warning emitted</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><code>let y = 6</code> 语句并不返回值，所以没有可以绑定到 <code>x</code> 上的值。这与其他语言不同，例如 <code>C</code> 和 <code>Ruby</code>，它们的赋值语句会返回所赋的值。在这些语言中，可以这么写 <code>x = y = 6</code>，这样 <code>x</code> 和 <code>y</code> 的值都是 <code>6</code>；<strong>Rust 中不能这样写</strong>。</p><p>表达式会计算出一个值，并且你接下来要用 Rust 编写的大部分代码都由表达式组成。考虑一个数学运算，比如 <code>5 + 6</code>，这是一个表达式并计算出值 <code>11</code>。函数调用是一个表达式。宏调用是一个表达式。我们用来创建新作用域的大括号（代码块） {} 也是一个表达式，例如：</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let y = {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        let x = 3;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        x + 1</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    println!("The value of y is: {}", y);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>输出:</p><div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">The value of y is: 4</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>是一个代码块，在这个例子中计算结果是 <code>4</code>。这个值作为 <code>let</code> 语句的一部分被绑定到 <code>y</code> 上。注意，<code>x + 1</code> <strong>行的末尾没有分号</strong>，这与你目前见过的大部分代码行不同。<strong>表达式的结尾没有分号。如果在表达式的末尾加上分号，那么它就转换为语句，而语句不会返回值。</strong>在接下来探讨函数返回值和表达式时，请记住这一点。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="带有返回值的函数">带有返回值的函数<a href="#带有返回值的函数" class="hash-link" aria-label="带有返回值的函数的直接链接" title="带有返回值的函数的直接链接">​</a></h3><p>函数可以向调用它的代码返回值。我们并不对返回值命名，但要在箭头（<code>-&gt;</code>）后声明它的类型。在 Rust 中，函数的返回值等同于函数体最后一个表达式的值。使用 <code>return</code> 关键字和指定值，可以从函数中提前返回；但大部分函数隐式返回最后一个表达式。这是一个有返回值函数的例子：</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn five() -&gt; i32 {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    5</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let y = five();</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    println!("The value of y is: {}", y);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在 <code>five</code> 函数中没有函数调用、宏，甚至没有 <code>let</code> 语句——只有数字 <code>5</code> 本身。这在 Rust 中是一个完全有效的函数。注意，函数返回值的类型也被指定好，即 <code>-&gt; i32</code>。尝试运行代码；输出应如下所示：</p><div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">PS E:\github\rust-projects\function-demo&gt; cargo run</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">   Compiling function-demo v0.1.0 (E:\github\rust-projects\function-demo)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    Finished dev [unoptimized + debuginfo] target(s) in 0.44s</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">     Running </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`target\debug\function-demo.exe`</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">The value of y is: 5</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><code>five</code> 函数的返回值是 <code>5</code>，所以返回值类型是 <code>i32</code>。让我们仔细检查一下这段代码。有两个重要的部分：首先，<code>let x = five();</code> 这一行表明我们使用函数的返回值初始化一个变量。因为 <code>five</code> 函数返回 <code>5</code>，这一行与如下代码相同：</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">let y = 5;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>其次，<code>five</code> 函数没有参数并定义了返回值类型，不过函数体只有单单一个 <code>5</code> 也没有分号，因为这是一个表达式，正是我们想要返回的值。</p><p>让我们看看另一个例子：</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let y = plus_one(5);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    println!("The value of y is: {}", y);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn plus_one(x: i32) -&gt; i32 {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    x + 1</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>运行代码会打印出 <code>The value of x is: 6</code>。但如果在包含 <code>x + 1</code> 的行尾加上一个分号，把它从表达式变成语句，我们将得到一个错误。</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let y = plus_one(5);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    println!("The value of y is: {}", y);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn plus_one(x: i32) -&gt; i32 {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    x + 1;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>运行代码会产生一个错误，如下：</p><div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">PS E:\github\rust-projects\function-demo&gt; cargo run</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">   Compiling function-demo v0.1.0 (E:\github\rust-projects\function-demo)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">error</span><span class="token url-reference url punctuation" style="color:rgb(248, 248, 242)">[</span><span class="token url-reference url variable" style="color:rgb(189, 147, 249);font-style:italic">E0308</span><span class="token url-reference url punctuation" style="color:rgb(248, 248, 242)">]</span><span class="token url-reference url punctuation" style="color:rgb(248, 248, 242)">:</span><span class="token url-reference url"> mismatched</span><span class="token plain"> types</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"> --&gt; src\main.rs:6:24</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">6 | fn plus_one(x: i32) -&gt; i32 {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |    --------            ^^^ expected </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`i32`</span><span class="token plain">, found </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`()`</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |    |</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |    implicitly returns </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`()`</span><span class="token plain"> as its body has no tail or </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`return`</span><span class="token plain"> expression</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">7 |     x + 1;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |          - help: remove this semicolon to return this value</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">For more information about this error, try </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`rustc --explain E0308`</span><span class="token plain">.</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">error: could not compile </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`function-demo`</span><span class="token plain"> (bin "function-demo") due to previous error</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>主要的错误信息 “mismatched types”（类型不匹配）揭示了这段代码的核心问题。函数 <code>plus_one</code> 的定义说明它要返回一个 <code>i32</code> 类型的值，不过语句并不会返回值，此值由单元类型 () 表示，表示不返回值。因为不返回值与函数定义相矛盾，从而出现一个错误。在输出中，Rust 提供了一条信息，可能有助于纠正这个错误：它建议删除分号，这将修复错误。</p><p>如果在 <code>plus_one</code> 函数中增加返回语句的话也能修复上述错误，使用 <code>return</code> 语句显示地返回，修改如下:</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let y = plus_one(5);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    println!("The value of y is: {}", y);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn plus_one(x: i32) -&gt; i32 {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let result = x + 1;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    return result;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>经过上述修改后也能正常返回计算的结果。</p>]]></content>
        <author>
            <name>Hanbin Che</name>
            <uri>https://github.com/hbche</uri>
        </author>
        <category label="rust" term="rust"/>
        <category label="函数" term="函数"/>
        <category label="通用编程概念" term="通用编程概念"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Rust 通用编程概念 - 变量]]></title>
        <id>https://hbche.github.io/my-website/blog/2023/10/07/rust-valiables</id>
        <link href="https://hbche.github.io/my-website/blog/2023/10/07/rust-valiables"/>
        <updated>2023-10-07T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[记录 Rust 学习过程]]></summary>
        <content type="html"><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="变量和可变性">变量和可变性<a href="#变量和可变性" class="hash-link" aria-label="变量和可变性的直接链接" title="变量和可变性的直接链接">​</a></h3><p>在 Rust 中，变量和可变性是两个重要的概念，它们用于管理数据的状态和访问权限。</p><ol><li><p><strong>变量（Variables）</strong>：</p><ul><li>在 Rust 中，变量是用于存储和管理数据的标识符。变量可以具有不同的数据类型，包括整数、浮点数、布尔值、字符、结构体等。</li><li>变量默认是不可变的（immutable），这意味着一旦赋值后，其值不能被修改。例如：<div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">let x = 5;  // 不可变变量</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></li><li>不可变变量的好处是可以确保数据不会在不经意间被修改，从而提高了代码的安全性。</li></ul></li><li><p><strong>可变性（Mutability）</strong>：</p><ul><li>在 Rust 中，如果需要更改变量的值，可以使用<code>mut</code>关键字来声明可变变量。可变变量允许在其作用域内修改其值。例如：<div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">let mut y = 10;  // 可变变量</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">y = y + 1;       // 可以修改 y 的值</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></li><li>使用可变性时，需要谨慎，因为它引入了潜在的并发问题和不可预测的行为。Rust 的可借用规则和所有权系统帮助确保了可变性的安全使用。</li></ul></li></ol><p>总结：</p><ul><li>变量用于存储数据，可以是不可变的（默认情况下）或可变的（使用<code>mut</code>关键字声明）。</li><li>不可变变量在赋值后不能更改，这有助于代码的安全性和可维护性。</li><li>可变变量允许在其作用域内修改其值，但需要注意可变性引入的潜在问题。</li><li>Rust 的所有权系统和借用规则有助于确保可变性的安全使用，防止数据竞态和内存不安全问题。</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="常量">常量<a href="#常量" class="hash-link" aria-label="常量的直接链接" title="常量的直接链接">​</a></h3><p>在 Rust 中，常量（constants）是在编译时无法更改其值的变量。常量的名称通常使用大写字母和下划线的命名约定，并且必须在声明时明确指定其类型。与不可变变量不同，常量的值必须在编译时确定，不能在运行时计算或更改。这使得常量非常适合存储不会更改的配置参数、数学常数和其他编译时确定的值。</p><p>以下是定义和使用常量的一般语法：</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">const THREE_HOURS_IN_SECONDS: u32 = 3;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    // const THREE_HOURS_IN_SECONDS: u32 = 3 * 60;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    // println!(</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    //     "The value of THREE_HOURS_IN_SECONDS is: {}",</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    //     THREE_HOURS_IN_SECONDS</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    // );</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    const THREE_HOURS_IN_SECONDS: u32 = 3 * 60 * 60;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    println!(</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        "The value of THREE_HOURS_IN_SECONDS is: {}",</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        THREE_HOURS_IN_SECONDS</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    );</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>输出结果：</p><div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">warning: constant </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`THREE_HOURS_IN_SECONDS`</span><span class="token plain"> is never used</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"> --&gt; src\main.rs:1:7</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">1 | const THREE_HOURS_IN_SECONDS: u32 = 42;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |       ^^^^^^^^^^^^^^^^^^^^^^</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  = note: </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`#[warn(dead_code)]`</span><span class="token plain"> on by default</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">warning: </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`variables`</span><span class="token plain"> (bin "variables") generated 1 warning</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    Finished dev [unoptimized + debuginfo] target(s) in 0.45s</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">     Running </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`target\debug\variables.exe`</span><span class="token plain"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">The value of THREE_HOURS_IN_SECONDS is: 10800</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在上述示例中，我们定义了一个名为 <code>THREE_HOURS_IN_SECONDS</code> 的常量，类型为 <code>u32</code>，并将其值设置为 <code>3 * 60 * 60</code>。然后，在 <code>main</code> 函数中，我们打印了常量的值。</p><p>如果打开注释部分的代码，输出如下：</p><div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">   Compiling variables v0.1.0 (E:\github\rust-projects\variables)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">error</span><span class="token url-reference url punctuation" style="color:rgb(248, 248, 242)">[</span><span class="token url-reference url variable" style="color:rgb(189, 147, 249);font-style:italic">E0428</span><span class="token url-reference url punctuation" style="color:rgb(248, 248, 242)">]</span><span class="token url-reference url punctuation" style="color:rgb(248, 248, 242)">:</span><span class="token url-reference url"> the</span><span class="token plain"> name </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`THREE_HOURS_IN_SECONDS`</span><span class="token plain"> is defined multiple times</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"> --&gt; src\main.rs:8:5</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">3 |     const THREE_HOURS_IN_SECONDS: u32 = 3 </span><span class="token italic punctuation" style="color:rgb(248, 248, 242)">*</span><span class="token italic content"> 60;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token italic content">  |     ------------------------------------------- previous definition of the value </span><span class="token italic content code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`THREE_HOURS_IN_SECONDS`</span><span class="token italic content"> here</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token italic content">...</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token italic content">8 |     const THREE_HOURS_IN_SECONDS: u32 = 3 </span><span class="token italic punctuation" style="color:rgb(248, 248, 242)">*</span><span class="token plain"> 60 * 60;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`THREE_HOURS_IN_SECONDS`</span><span class="token plain"> redefined here</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  |</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  = note: </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`THREE_HOURS_IN_SECONDS`</span><span class="token plain"> must be defined only once in the value namespace of this block</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">For more information about this error, try </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`rustc --explain E0428`</span><span class="token plain">.</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">error: could not compile </span><span class="token code-snippet code keyword" style="color:rgb(189, 147, 249);font-style:italic">`variables`</span><span class="token plain"> (bin "variables") due to previous error</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>总结：</p><ul><li>常量的类型必须显式指定，它不能像不可变变量那样进行类型推断。</li><li>常量可以在任何作用域中定义，并且具有全局作用域，可以在整个程序中访问。</li><li>常量的值不能在运行时更改，它们是在编译时确定的。</li><li>常量名称通常使用大写字母和下划线，以便与不可变变量区分开来。</li><li>同一作用域常量不可重复声明，不同作用域常量可以重复声明，但是 Rust 编译器可能会报声明的变量未引用的警告。</li></ul><p>常量在 Rust 中是一个重要的编程工具，用于存储程序的配置信息、常量参数和其他在运行时不会更改的值。它们有助于提高代码的可维护性和安全性。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="遮蔽">遮蔽<a href="#遮蔽" class="hash-link" aria-label="遮蔽的直接链接" title="遮蔽的直接链接">​</a></h3><p>在 Rust 中，遮蔽(shadowing)是一种将一个变量引入到一个更内部作用域的过程，以隐藏(或遮蔽)外部作用域中具有相同名称的变量。遮蔽允许我们在 <strong>同一作用域内多次声明同名变量</strong> ，每次声明都会创建一个新的变量，新的变量会隐藏先前声明的同名变量。这个过程不改变变量的可变性，但是可以改变变量的值和类型。</p><p>以下是一个示例，说明了 Rust 中的遮蔽:</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let x = "你好~";  // 外部作用域的 x</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    println!("x in outer scope: {}", x);    // 打印外部作用域的 x</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        let x = 10; // 内部作用域中的 x 遮蔽了外部作用域的 x</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        println!("x in inner scope: {}", x);    // 打印内部作用域的 x</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    // 新声明的变量会遮蔽先前的同名变量</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    let x = x.len();</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    // 在这里又可以访问外部作用域中的 x, 因为内部作用域的 x 已经超出了范围</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    println!("x in outer scope: {}", x); // 6</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>输出结果:</p><div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">x in outer scope: 你好~</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">x in inner scope: 10</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">x in outer scope: 7</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在上述示例中，我们首先声明了一个名为 x 的变量，并在外部作用域中赋予它值 "你好~"。然后，在内部作用域中声明了一个名为 x 的新变量，它遮蔽了外部作用域的 x。在内部作用域中，我们可以访问和修改内部作用域的 x，而不会影响外部作用域的 x。一旦内部作用域结束，内部作用域的 x 超出了范围，我们又可以访问外部作用域的 x。</p><p>遮蔽通常用于引入新变量，而不是更改现有变量。这允许在不改变可变性的情况下，对变量的值和类型进行更改。需要注意的是，Rust 的编译器会警告您关于未使用的变量，因此遮蔽可能会导致警告，但可以安全地忽略这些警告。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="问题">问题<a href="#问题" class="hash-link" aria-label="问题的直接链接" title="问题的直接链接">​</a></h3><ol><li><p>代码是否能正常运行？</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    println!(</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    "The value of THREE_HOURS_IN_SECONDS is: {}",</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    THREE_HOURS_IN_SECONDS</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    );</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    const THREE_HOURS_IN_SECONDS: u32 = 3 * 60 * 60;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"> }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在您提供的代码示例中，虽然在 <code>println!</code> 宏中似乎引用了常量 <code>THREE_HOURS_IN_SECONDS</code> 在其声明之前，但实际上它可以正常运行。这是因为在 Rust 中，编译器会在编译时进行静态分析并执行名为 "名字解析（name resolution）" 的步骤，以确定变量和常量的词法作用域。</p><p>具体来说，Rust 编译器会在整个代码文件中查找常量 <code>THREE_HOURS_IN_SECONDS</code> 的定义，而不仅仅是在 <code>println!</code> 宏的内部。如果找到常量定义，它就会将该常量的值插入到 <code>println!</code> 宏中，然后在运行时将其打印出来。</p><p>这是因为常量的值在编译时就已经确定，所以编译器可以在编译期间执行这种操作。这与变量的行为不同，变量的值在运行时确定，因此不能在使用之前声明。</p><p>虽然这在 Rust 中是合法的，但为了代码的可读性和清晰性，通常建议在使用常量之前先声明它们，以防止可能的混淆或误解。</p></li><li><p>Rust 中常量是否存在遮蔽</p><p>在 Rust 中，常量不会发生遮蔽（shadowing）的情况。遮蔽通常是与变量相关的概念，而不是常量。常量在其作用域内是唯一的，不允许在相同作用域内多次定义相同名称的常量。</p><p>例如，以下示例是非法的，因为它尝试在同一作用域内多次定义相同名称的常量：</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">const MY_CONSTANT: i32 = 42;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">const MY_CONSTANT: f64 = 3.14;  // 错误：常量名重复定义</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    println!("The value of MY_CONSTANT is: {}", MY_CONSTANT);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>与变量不同，常量不能被遮蔽或重新定义。一旦常量在某个作用域内定义，它就不能在相同的作用域内再次定义或修改。这有助于确保常量的唯一性和稳定性。</p><p>Rust 常量是否允许允许声明多次
在 Rust 中，常量不允许在同一作用域内多次声明，即常量的名称必须是唯一的。如果您尝试在同一作用域内多次声明具有相同名称的常量，编译器将会产生错误。</p><p>这是因为常量在编译时被赋予一个确定的、不可更改的值，并且具有全局作用域，所以不允许多次定义相同名称的常量。这有助于确保常量的唯一性，防止在程序中引入混淆或不一致的值。</p><p>以下是一个示例，演示了在同一作用域内多次声明相同名称的常量会导致编译错误：</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">const MY_CONSTANT: i32 = 42;</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">const MY_CONSTANT: f64 = 3.14;  // 错误：常量名重复定义</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    println!("The value of MY_CONSTANT is: {}", MY_CONSTANT);</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在上述示例中，我们尝试在同一作用域内两次声明名为<code>MY_CONSTANT</code>的常量，一个是<code>i32</code>类型，另一个是<code>f64</code>类型。这将导致编译错误，因为常量名称必须是唯一的。要解决此错误，您可以选择不同的名称或将它们分开到不同的作用域中。</p></li><li><p>Rust 中常量和不可变变量的区别</p><p>在 Rust 中，常量（constants）和不可变变量（immutable variables）之间有一些关键的区别，尽管它们都涉及到不可变性。</p><ol><li><p><strong>赋值和可变性</strong></p><ul><li><strong>常量</strong>: 常量在声明时必须赋予一个确定的值，并且一旦赋值后，它们的值在整个程序运行过程中都不能被修改。常量在声明时使用 <code>const</code> 关键字，并且通常采用大写字母和下划线的命名约定，例如 <code>const THREE_HOURS_IN_SECONDS: i32 = 3 * 60 * 60;</code>。</li><li><strong>不可变变量</strong>: 不可变变量在声明后可以赋值一次，并且一旦赋值后，它们的值也不能被修改。不可变变量在声明时使用<code>let</code> 关键字，例如 <code>let x = 10;</code>。</li></ul></li><li><p><strong>作用域和生命周期</strong></p><ul><li><strong>常量</strong>: 常量具有全局作用域（global scope），它们可以在整个程序中访问，无论它们被定义在哪个作用域内。</li><li><strong>不可变变量</strong>: 不可变变量的作用域通常是有限的，限定在它们被声明的代码块内。这有助于减小不可变性的范围，以提高程序的可维护性。</li></ul></li><li><p><strong>类型和可变性</strong></p><ul><li><strong>常量</strong>: 常量的类型必须在声明时明确指定，且不能随后更改。常量通常用于存储编译时确定的值，例如数学常数或配置信息。</li><li><strong>不可变变量</strong>: 不可变变量的类型可以通过类型推断自动确定，也可以显式指定。不可变变量通常用于存储运行时确定的数据。</li></ul></li><li><p><strong>编程惯例</strong></p><ul><li><strong>常量</strong>: 常量通常用于存储不会更改的数据，如数学常数、配置参数、全局常量等。</li><li><strong>不可变变量</strong>: 不可变变量通常用于存储会在程序运行期间发生变化的数据，但在某个特定点上不需要改变的数据。</li></ul></li></ol><p>总的来说，常量和不可变变量都用于实现不可变性，但它们的用途和语法略有不同。选择使用哪种取决于您的需求：如果需要在整个程序中共享不会更改的值，常量是一个不错的选择；如果只需要在特定作用域内保持不可变性，不可变变量更合适。不管哪种方式，Rust 的强类型系统和不可变性保证了代码的安全性和可维护性。</p></li><li><p>Rust 中遮蔽和 mut 的区别</p><p>在 Rust 中，"遮蔽"（Shadowing）和"mut"（Mutable）是两种不同的概念，它们用于处理变量的不可变性和可变性，有一些区别：</p><ol><li><p>遮蔽（Shadowing）：</p><ul><li>遮蔽是指在同一作用域内声明具有相同名称的新变量，从而隐藏（遮蔽）之前同名变量的值。遮蔽允许您在同一作用域内多次声明变量，但每次声明都会创建一个新的变量。</li><li>遮蔽可以用于在同一作用域内改变变量的类型，例如，您可以先声明一个不可变变量，然后遮蔽它并声明一个可变变量。</li><li>遮蔽后的变量，包括之前的同名变量，都可以具有不同的类型和值。遮蔽通常用于需要在相同作用域内引入新变量并保留之前变量的值的情况。</li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">let x = 5;  // 不可变变量</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">let x = x + 1; // 遮蔽 x，创建一个新的不可变变量</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">let mut x = x * 2; // 遮蔽并创建一个新的可变变量</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></li><li><p>mut 关键字（Mutable）：</p><ul><li>"mut"是 Rust 中的关键字，用于声明可变变量。使用"mut"关键字声明的变量可以在其作用域内修改其值。</li><li>声明一个可变变量后，您可以在需要的时候重新赋值给它，而不需要重新声明变量。这允许对变量的值进行更改。</li></ul><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">let mut y = 5;  // 声明一个可变变量</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">y = y + 1;      // 可以修改 y 的值</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></li><li><p>总结:</p><ul><li>遮蔽允许在同一作用域内多次声明变量，每次声明都创建一个新的变量，可以改变变量的类型和值。</li><li>"mut"关键字用于声明可变变量，允许在其作用域内修改变量的值。不使用遮蔽，只需使用"mut"关键字即可实现可变性。</li><li>两者通常根据需求选择使用。如果您只需要修改变量的值而不需要改变其类型，可以使用"mut"关键字。如果需要在同一作用域内引入新的同名变量，可以使用遮蔽。</li></ul></li></ol></li></ol>]]></content>
        <author>
            <name>Hanbin Che</name>
            <uri>https://github.com/hbche</uri>
        </author>
        <category label="rust" term="rust"/>
        <category label="变量" term="变量"/>
        <category label="通用编程概念" term="通用编程概念"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Rust 环境安装]]></title>
        <id>https://hbche.github.io/my-website/blog/2023/09/26/rust-install</id>
        <link href="https://hbche.github.io/my-website/blog/2023/09/26/rust-install"/>
        <updated>2023-09-26T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[记录 Rust 学习过程]]></summary>
        <content type="html"><![CDATA[<h2 class="anchor anchorWithStickyNavbar_LWe7" id="环境安装">环境安装<a href="#环境安装" class="hash-link" aria-label="环境安装的直接链接" title="环境安装的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="linux-安装">Linux 安装<a href="#linux-安装" class="hash-link" aria-label="Linux 安装的直接链接" title="Linux 安装的直接链接">​</a></h3><ol><li>安装最新版本 rust</li></ol><div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><img loading="lazy" src="/my-website/assets/images/linux-rust-install-01-74457b5e4c9eb8f55ab23572dd5b8824.png" width="887" height="862" class="img_ev3q">
<img loading="lazy" src="/my-website/assets/images/linux-rust-install-02-858248dd88b1d2b2887dc2c710efb88c.png" width="1224" height="786" class="img_ev3q"></p><p>Ubuntu 或者 Debian 也可以使用以下命令进行安装</p><div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">sudo apt install rust</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol start="2"><li>如果当前 Linux 缺少 <code>cc</code> linker，在使用 <code>rustc</code> 程序时会报错</li></ol><p><img loading="lazy" alt="linker报错" src="/my-website/assets/images/rustc-linker-error-851d1b6be971a9085baaf3c489ecb847.png" width="606" height="122" class="img_ev3q"></p><p>安装 <code>cc</code> linker</p><div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">sudo apt install build-essential</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol start="3"><li><p>检查 <code>rustc</code> 和 <code>rustup</code> 命令是否可用，使用 <code>rustup</code> 对 rust 进行更新
<img loading="lazy" src="/my-website/assets/images/linux-rust-install-result-4f941f6c042be3a685b3df860ca01bc3.png" width="849" height="185" class="img_ev3q"></p></li><li><p>卸载 rust
<img loading="lazy" src="/my-website/assets/images/linux-rust-install-uninstall-85a80cf88a9d3834fe500f66c87cc96c.png" width="672" height="342" class="img_ev3q"></p></li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="windows-安装">Windows 安装<a href="#windows-安装" class="hash-link" aria-label="Windows 安装的直接链接" title="Windows 安装的直接链接">​</a></h3><p><a href="https://rust-lang.github.io/rustup/installation/windows-msvc.html" target="_blank" rel="noopener noreferrer">参照官方教程</a></p><ol><li>下载 rust 安装程序并安装
<img loading="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA8AAAAHgCAIAAADlh5PTAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAEXRFWHRTb2Z0d2FyZQBTbmlwYXN0ZV0Xzt0AACAASURBVHic7d1duqK4FgZgqp+63INi6AygB3UurENT+SMLgqK+70V3iZAsAuq3Meqvn5+fCQAA6PPPqwsAAIB3IkADAECAAA0AAAECNAAABAjQAAAQIEADAECAAA0AAAECNAAABAjQAAAQIEADAECAAA0AAAECNAAABAjQAAAQIEADAECAAA0AAAECNAAABAjQAAAQIEADAEDAr3///TdZNM/zEzpelmXbXfHmpZUsy9Lf/lrew3OG6Iaix+UJxxEA4Ml+z/OcRMlQsjws6Tcv4zpJGu5ZPxmfoeUAAPBOxk/hGJIv53m+LkwPb7y2y58XtaND11j/8wYHAPgSd5kD/bTLz1F5YfesEwCA5/j9+N/2cmBxFnLxZnGTfOWa2rSNZD508a5tCz113jb1rgU3Ks/3ona8+tcvFtAez9BxaazfOE9qdZqDDgDcx58AvSaeZFLyut72Zm1OcN7IMUn82naU99tZ5xVXuLf9FvPr1JHgH+uv5a3/WG9u71rbTMZhnSnRv37y71r9eRzvPC6N9WvnSa3OWvsAAC/x+3wT54PpsXS7u0nx+utAtXR+ILUnf7cUWzvQVHvNxt9LZ1x9edjlZwDgtf4K0Hl6K8ovUo6va1C/xavUHyC6O5fu/sDzoVjnq843AICig1ega1MCDrQTynahfodM28j/qLhiNkhUtIBnXhU+eT5c2j4AwHnpt3DUEm1xXm9bfzLuzEM9De4Wf1IxvfXEvt1mG+13bhtdf/57vvjhxk8O727XH/buAQDw7v77JcJkxnDyCbB58/0MSaDJA9+2hV3FD5MV22/0W6xzW0lxp2r1F4vsXzlqqX/9xaoxRD071ZgCsR2ivPee437geCVdt+s8cLwAAK7z6+fn59U1fLubzEm4SRkAADd3lx9S+VqPy6svn6VwkzIAAO7PFWgAAAhwBRoAAAIEaAAACBCgAQAgQIAGAIAAARoAAAIEaAAACBCgAQAgQIAGAIAAARoAAAIEaAAACBCgAQAgQIAGAIAAARoAAAIEaAAACBCgAQAgQIAGAIAAARrg/SzLsizLq6sA+FICNMD7mef51SUAfK/f+TWMT3pefuzdW+zRsix5nW9U/0nrnj7GIdnxNxqH5Dg2Hl/JXZ17d6vz5I2OCwAM9HuNLOui4is01xnyPuzNo8xueWto3i55Qr9Xazy+Hv/tf7iFzpOX7/hJX/InwZnuPFFP73+eA+9r/BSOW03Lm+f5/s+tjSL767/5bp4s7/BxfMmwXPQQCJ0nz9nx6x5fh5uNDv4Vf7b1O9Nde9tbPQ83nKzz5s97wAczBxqGcVEQAL7B78f/tpcB1neWp83f98WbxU3ylYvWlbfv3RfbT9rpnyybN3u43+hlqmLXUY36i8U3Nqwd392mOluuNTJwdkqx5Wi/jfM8/0fezj3Dcfvw1R657fO/Z/2eM3A69ziq1d9+vHe+rd9ef/e8Kg5C50Pp8Pm52/IUH4e8ntDzYfGR0lNqo87G83+7tdpB7G8HoNOfAL0+Ca7PMvPfc1K3N5fKx6TyRhrWldf1G+1vn9Ab+W9qvswf7re2vzXFgg+o1b8tvtZFbQDXm41xqCl22qgnOm410XGo9Vs7vtsd2f7jcP1zad5zsjsDNQ5fPiad53/P+rV+Rz2OavXvPt47R7ixfud59XgcbZfnh76xU+vN2vK1/d3He+d+na+nXWeyQruG2jq1fnt2oTFQ/QMC0OOf802cfFbavva010xeqM50Guq3tuHuCv2RK6pRQ/R1on8cGvs16pVp2byr0GPIaZB0VxvA/jhSHJ/VkSqPSoJd7a7kH8XxH/jQ62+nUf+loo+gWuh8ST1v1NcorzpPgG/2e3tj7rh8MmVPUlc84b7qSbAWHaL7u2RvvD5HrbtRZVy6X3Pkferhiqk3dNyTq1/DKnuiUcd31OPobt70sLY1jsvVzydXe5c6gXf0e3+VkqvfGnvVi2ut39D+vvC9wrnyruiQej7+PdD8D8jD53nn36K3MrDgIY+jG2rs1/q3xxPLGaZ2XHqO4529S53AO0qncNQuPm0Xdv5ZP/aq55S9VXppp9umDrf5qusf7SuI56s60MKt3lJI1MLuB1y+Oja1YOyOn3kc7dY/8Dy/ev3rGjnZxcnn8+HP82e2bZznH/BwBm7l17///vv4V/Lu83otc7239vZuLXnsXqZtNNJ4q3dbRv6O+W6dB/rd3d9cUsOxoWjXX9yd6e8dLzbVMw7tUouD3C6vfyjyOBsah3a/tfNqqXwIKe+3UXmxgMbm0UMQOk+mvyeUd+5U4/jm63fedfhxVKw/aaq4Qs+ZlrcWOq+KJUV7nDrOz3Y9Pb0cPq+K9dSWF/coVEBPv7XNd8+TnnYAQn79/Py8uoaDQq9YANfxdATwVd41QIeuxABcJHrBG4AP8K4BGgAAXiL9ECEAANAgQAMAQMDgAL0sS/79A+tdo7oY0g4AABxw8IdUQkKRt/GJHNEZAICXe96HCPu/5qm9pq+LAgDghcyBBgCAgD9TOPKvVc5/Wap279rWge9mbmwS+nZVvzgFAMBz/J6yny9+/Hve/KLynP1udvHf+a/RttXa2d7smbBR2xYAAIb7ZypdV26Lrn+gnW0o99lBAADu468pHElaXS8859d0i+sfMLYdAAC4WjqFo8eoORID51qYswEAwHP89S0cxakUjZh73W+jrEsOhOzttq5MAwAw1p/vgU6mUux+Jq+4fpJWa1Oc8y/uyNupVdJup9ivi9MAAAz0vB9SAQCAD+CHVAAAIECABgCAAAEaAAACBGgAAAgQoAEAIECABgCAAAEaAAACBGgAAAgQoAEAIECABgCAAAEaAAACBGgAAAgQoAEAIECABgCAAAEaAAACBGgAAAgQoAEAIECABgCAAAEaAAACBGgAAAj49e+//+ZL53l+eiVQtSzL5LS80mOEp/8PcvHmpeO/LEt/+2t5D8MLG7W/Lzxva+MZGmcAan5Pm9fI7YulyPLZvvz4Ht79V43b1f3O87yNVsnNSyVpuGf9bWHRzRs1fMbDoTYgQwYKgId/8teMx5LPeC15oZu/XL3X8Z3neWzB97nY2em1x2v4+F/X+LHHXVLAqJIG7lr/ftU6vfQgAnwbc6CB1Bu90f8udQLwSX7vrpHMhkwWNpZv76qtf77f4oWZxxvQyT+KjSftrOt39ltcf12Sd33gcma7nqTTWv277e+Oz4Ei23dtC84P0/bm7gg0DkFtqx6N45hXFa2nsb95ne1D37MLPSvPlWkbPQd328LUsV9nUu9unfnJ0znOu0WGHheN87bneWbKTq3G88nJvyIaz6sHnlIAvsFOgN6+UC2bSdLJk3hted5IfvNkv9tX0+Qfy7IUt220E+23uH5xq8b4nBmHbae1enra3x2faJHtu7b9PpZsX6en0st2LVvkTUXPz5racSzuS7Sexv4eGM+i6MlQUxz/Ym1T8ziOqmcqJfWpcrw665n+PhWnvv1t70LtvK09TnfrSbobNZ6183OqnM8ATLtTOE6+yB3bMH8JPF9D8jq6u360/QN2t62Nw/ZV82Q90fFpN5K0UKt/u/zMACYtnG/qQKeNu66oJ9Rm4zxpO5bGdjc5XE+ttTMn7Wv1DO+Tx3O3l2c+vgDub38KR1HxKTu/2NNe/42MesmvjU9U8WrfQAci13RlPVE3KeOYedyb5pcelwPn8/B65id+W8jVXjieb/14AXiJgwG69uSevxXYXv9djKq/Nj4hT0gMofZvmGDuVk/IqPE80E40ioXO5xfu17t4yXhOb/54AXiJnSkcPdZX3M6X3t3VklfxM1dHtrWNepE4dnX2wIa743D+ulHP+PT3kqxZq3/+ex7qyU6jVR1u/9KrdMmlx2VjbOM9Oh8pPc2OGvwDQl3f4RLs4efPscXvtjbqtAR4a79+fn6m7AMr+ZLazeImyfLa+m15ScV28liWvAO+Liw2XmyncbNz/W0vPePT0G65uMu1rfKW+8enp8hia7VKtpsUz7p817bttAezVv/uiVG0XbNxYoyqZyl9qOvA8Z2ax6WxSaP4qe98ro1zsZ7o42J3/fZJWDua7fMt7/pYnY3jeHi/OscztF+7K3c+fQF8qj8B+iPlUYAbcpgSxQD9smoAgMzHBujOS3S8lsNUFH0HAAB4po8N0AAAcIUBHyIEAIDvIUADAECAAA0AAAECNAAABAjQAAAQIEADAECAAA0AAAECNAAABAjQAAAQIEADAECAAA0AAAECNAAABAjQAAAQIEADAECAAA0AAAECNAAABLQC9LIszyoDAADeQytAz/MsQwMAwNavn5+f9cayLPM8J2sUF9asgbtzk8f6/e1HXd1+u+tiv6HxbDQ+vWi/OiVnQvHmpfUfO28fhhc2an+vrjPK4xeA7/T78b8hV5q3Ly3DX2buHxlXtcF8i8v5o8b58fbF2k5y81LRcU4KG/VYmEafrlfUSe6tH78APMefKRzzPNde7DsnciSv7p1bNfrN1+xZ7XD7u/pfPmudDizmuv16TsYdWP/VjR+LTUkBl+7vCzX2a0jc/NTHLwDvzrdw8Axv9Mb3PevMB/CedQLAN/h9dQfJe9nbm+0J0417O2daF1dbC2jcu0rqzN+Xj8757rdtuT2fuLZVfxfF+Qa747PbxVyZttFT/7aFqXL+tJvqt1tnftLu1lNsp72/Z3Yhb6dYyVx5X6gxzo3HS22/GuNWu9neqfs/fhvjXysVgLd2eYBOXrMbcXBr2ZtO3fNSVGz/UUCx/aUyx7R4b0+RZ2xT3ZzNJ55K4xatp7Zftaby8Tm2yz31T6WolNwcOP55gpwq49NZz1Q6f5JOR41nsZ3tOZP8o7E836/G46W2X41x257Du/v7Lo/f2vg//r0t71j7ANzQHadw5C+9jXuP6WmhM4BOt3lpHFjP+RHeOnbInjz+a+g839TnGXI+NP7YuKKemzx+t38zXNcLAE92+RXosa5+qVuyt2LbildJx9bTc63uOfVMXzD+odHmVl54/vi7C+Db7AfoUJ5YsvfBx6q9Gzu2/YfdXu6WtJ5QT7T9aDR5yfjf7TgW5cn+LcpOzKWpMmPbX//9zMfv2x0IAE4aNoVjfYGfs0mKWz1xKkld+SYXXWHtbDNf7brrT8cuiB6rJ7pV//qhy+cH1nnO9b9Q11eXdHV6Hlj/067O3uTx62o0wDf480uEyZP+dnZg6HV6bSfZaru89rZpY5NiC/kmtWJq7dSarTWeXzxL9iVpM2lnt/3aXtRGJm+nWE9PF1PH+CRdD69/d7+mylB3jn+jwvb6tePe6LrzPI+O5+7jq7+SfHnyyNp9+BwYtynylPJGj9/G+NeKAeCt/fVT3on+l7ritpOXDeBvZ55VAOAmWgEaYBR/VAPwMQRoAAAIuPB7oJNZgACfxxMdwBe6KkCb6Qh8g/zziwB8vEsC9Pek52VZhrx2RtsZ1W+7i0vbv5UnjCcfTIYG+DZP/SXCV32K6IafXrq6pDPtv2MUuOEhfmvGEwAaxn+IsHb5eV3+5OvTr+p319X1nGz/bsO16+0KvjnjGWXEAL7HhR8irHnVa4zXNgAAznvGFI51SkDx577m0i8L5r/s1V7e32+tnXY97fYbv23W6LennWJTjfLy9pN9L94sNlU06vfVenahNhqNeorLi78MV7yr9s5J495ktd1xTprqOc93u96tqlhY//nZ0/7092DOld/C3F0/32S336k5nrXjsvt43x0ff5ADfLMXTOFIFk6bl7riXIvd5dF6Gu0U6znQ/vT3a3ZP/e06d/ei0WDP8jPtRzX6Ld5VW//w/naOQM8KtZVD9XQuj2qM2xQ/P9vtJ+1MpQdRz/on+42OZ0+p/eNz+EgB8HZeMIUjsb7k3OS1Z0g9N9mXtiRGHN58VL9J/sgPxLE6D6vVc1K0neHjfKbNaNdz39dTvPCxVjzNrjjuAHySp34LR7/ai+6TI9RrPcLH+t8ruliyd7R369nefE6/h9e/ica4Fet84ThfbUgZA8cn6ibDCMDLjQ/QQwJfbXNXgwY6cJjab2Ff1O/JOu+gNm495/nTxvkJrriK/8zdbHR0w9EG4Dqvn8Kx6yOvRncWf/ivkdCgnbysuyzLsWORbJVcWczbbPRy7K623XoaDmy4rnb1OF+0SXHzxtl7uIsztR14p+Xw88/h4wXA/Y3/EOHDkn1SZzVvPjmULNxuXrwr9NZto4u8nXY9/e2vC3dvLpW31/OhaAzOVNmv+e+vQWgvr62ctN/uN3pROe8334Xd9Xf3N1/SGPm831o97f1q97J7Pl86zgfOz9328/prm7ePS35zt9OpYzyn0n4l8u4a52Fxea2F0PEC4F1cFaAn72l+E8f6Od5inN+iyIG+bX8BmC4N0HwJAeI53mKcQxfsAeBNCdAAABDwBh8iBACA+xCgAQAgQIAGAIAAARoAAAIEaAAACBCgAQAgQIAGAIAAARoAAAIEaAAACBCgAQAgQIAGAIAAARoAAAIEaAAACBCgAQAgQIAGAIAAARoAAAJaAXpZlmeVAQAA76EVoOd5lqEBAGDrT4BeNrZ392fo7ebFpq5W625IGc/fnW3XoeU0RI/jC487AHBbv6dpWpZlnud1UXKzUx61DzRyzKdGzKv/JJieeIwAAD7G/ocI7z+RY57nYhCsLR/YxQH9gzl2v171582tRIeusf7NHxQAwHV8CwcAAAT8np5yMXK9XLf2tU4hSO5KphYUb04nai52126wuE6t/mSTYl/59Inz+9XQ6LfW9bb+dknJOBSPVO3obxdG1y8WUCtj91i3j1dtxBrHsbG8WAAA8EZ+J7ePTYBu27a5/vuRdfK7khkj25vFdqLWpFW8WdtkKmWgYv15bXlkzwPZ+f3qqb8YHHvqb5SUjMP2+E7//xBe/vdD3n50/bzmbT1Jeck4NAZhKh2vfJfzrRp11toHAN7UX1M4zqe3Yh5NLgcW7+psvNZOSC2UH2vq/Dqj9uuAUWE9+YOkdle0qfaayR9CPY2HCrjI1e0DAFf77wr0Fdc+t41PIz6POKqdS+UXQXc3udt+XV1GtP1L6zlwvGqKdQ5sHwC4gz8BupGezwfrUdF8YMSfs8myY/VPgehZ4fnudhX2mfWcORy1DUe1DwDcwT/TE+doHmi5uMlNLtPWdJZXnIw7upaufs+vf2ZKzOF6kqk4hxsf8q5IY/nNT1cAIOrXz89PY2pyfx7aTkLIr+8mUxTm+ke78pvbpvJ2piyg1KYUJzsS3bWknd2Ca/1Om73Il5zfr4Zi4+2bPe03jnitkbz96PrJXfPfk++L5090PA8fx2g7AMB7+fXz81O778DVxDfy2Xv3TDcZyZuUAQB8vFaA/lT5hUMOSy5df3kZAMA3+MYADQAAh/2zv8pRPjsFDR4gAPCmrgrQJqRCW/65RgDgLVwSoKXnmmVZZCZWMjQAvKMLp3DkxMfbGnVo7naI71YPAPABxgfo2uXnx/L7XHJ7SRmPEXh+v7tGVXW3vbtbPbn7PCIAgE5PvQL9cP9MAwAANb+f0Md6ga3nl9uKP+nX82N4xXaKjQypJ2m/8Rt4xaYa9RdbK26Vq+1sbTCj1z5ru5C30z6O0TprXdfGp3+/iocv9COFPedtrR0A4B2N/x7o9hSOxpIl+ynmNZq0A0etnTwM1bo7Vk+jyPZdnf3ubphICm6EwuHt79bf+e9inbV/XzFuJ9uvnSehEwAAuLkXTOHotEaKM9liYC4p1rNdWLvKGK3hcM1JjBvSZmf7o9op1pnky1dlzc5+d4+7rAwA7+4ZUzie4GSkG95OSBK+8yvZ/ZZsIsRYofYfq63/PdzObj0XGXVcGu0AAO9ofIAuBqarjeruDlc3t6MXqufqYR/V/sA6rz5eQ45Lo538JgBwf/edwnHYsau2x9pZ1zkTgzoL7t+vA9dlQ5s0Vs7nsTRGprPT5Apu6HidORlGHZcDNbzknRAAoNP4DxE+5J+sWtXeCl8/cVVbud1drZ3ize1Wh+tZ5ydsl3fu7IFNeoYimRox730TyPZmPho97Sd1Fu/K24zWWVwy1cfn2H7VSurp98Bxn/YGp1EwAPBCVwXo6Qvem/74HeRSzh8AeFMXBujPVrwgCgDAxxOgAQAg4AM/RAgAANcRoAEAIECABgCAAAEaAAACBGgAAAgQoAEAIECABgCAAAEaAAACBGgAAAgQoAEAIECABgCAAAEaAAACBGgAAAgQoAEAIECABgCAAAEaAAACWgF6WZZnlZH2+6quAQCgrRWg53l+SZCd5/n5nQIAQI/fj/9tg/I2vz4ydE+iTaL2TULwo6qXFFMbt87xZCt6HF943AGAj/d7yiLdsYSXRO0zMfHdI2btsv2Qy/miIQDAa+1/iPDYRI4z0z/a6TDU7DzPo7Jmf7+1To8Vc89L+08WHbrG+qbXAwAn/TN9ayYDAIADfie3L5o+kc+xXqcirHft9ruu2TmNodhyu9/i5d5Gv/3FH9De3936ey7kr+OwnXuzbp53UTuO/esXC6iVkXdR3ItGScWVG8exsbxYAADwhf4L0NdNri3OsX5kptC06TUedRaZxKl1Ya3fvM52v6PmfO/WXwyOPfU3SkrGYf3HenN7V7HB9TiG1s9r3taTlJeMQ2MQptLxync536pRZ619AODL/TcHeg21z+z+VZf0evrdXad4nfU5Ro3b2k5+6Ld3RZtqr7kNpgNPgKvPJZefAYCHdArH3P29dZ8nvwi6u8mymYdwUVUhV5cRbf/Seg4cr5pinQPbBwA+SeFr7BJflaf7p0D0rPB8d7sK+8x6zhyO2oaj2gcAPsn+19gd84S0MfzqZmeDxcm4Yyvp7Pf8+rX5ypfWs72yW2skVPwxu13f5F0FAOBufv38/EzNbyHozFW1GbT5vfmnx/KbPX31zLXNS2r0296FYr/JFI7ix9dqU6X7A2ux8fbNnvaX+tdf1BppHMfO9ZO75uz3d9aVa9Njdks9fByj7QAA3+lPgC7ynvVnu8nxvUkZAACdWgGaDxa65P/xZQAA9BOgAQAg4KoPEU43/gzWsiy3rY335aQCgC/xxt/CcdhtC+Ot3efrwAGAS6U/pDJEnp47vzeDi7z7+Ne+/aP2jRlT5VtK2l3Uvpdjqn9lR3LX/MW/QwQA3+PCKRz9njynQsR5goHH9HG8HtaFxXy8rrOumdzst21wzn6SMOkOAPgq4wN0MZ42osYaj56WoZ8Tel71bn6x3ydEvQ/41uQhh8xEDgD4eLe4Av3wjpGLqyV/jyUnyai06k0JAKDfJXOgE7V5qOvynhm6tZ/cS25OzTmyjS7y38DLNy/uRaOpxi/e5S3v9rtbT63f4viv6zTuzbsoah/H3fbvnFz7p1ADAN/jGQE6z7jJ8p50Mv/98aztzfzjX8V5q+1LlWtT22a3DSbt9zSVR8ltqF3n0fb0W/t3san8Mu1UysTbTrcbNvoK7W+tqeh47vZ+soVGU6FxAAC+xI2mcOzahuDrAs02o1/UcjHKX9dvw9V9jW1/+b+BbSaN1+7d/QMMAPgez7gC/QFGhad84kRDbX7FwHqi/Y5yrP6BF5uTYtp/2wAAbI0P0BelnG3j09PnpA7pLjosjfUv3f0nTFfob7/ndBp4efj82WuyBwB8vHeawnHGwCuL0aby9TtbWKcpt2cX1O46vMud/UbrGbX+S5yJxddNOwEAXuLXz8/PFe023hbfXd7f8nZhsZ3tVIT2pet2MbX2d0st1rMtptHvUv+wXbuepN9iF8kkjWSgGmU0bPtttL9bf63lqbRT2yWd49NouZZ0iydV8a7dwwEAvLurAvR02XvZ3/MW+eEg+6b9vjsDBQBf4sIAPdwXXsk7duX7ffsFALi/dwrQAADwct/yIUIAABhCgAYAgAABGgAAAgRoAAAIEKABACBAgAYAgAABGgAAAgRoAAAIEKABACBAgAYAgAABGgAAAgRoAAAIEKABACBAgAYAgAABGgAAAgRoAAAIEKABACBAgAYAgIB/pmlaluXVZQAAwHv4Z5qmeZ5laAAA6PFnCocMDQAAPf6bAy1DAwDArr8+RChDAwBAW/otHDI0AAA0pAF6WZZ5nl9RCQAAvIG/ArT0DAAAbf8FaOkZAAB2/QnQ0jMAAPT480uE0jMAAPT49fPz8+oaAADgbaTfwgEAADQI0AAAECBAAwBAgAANAAABAjQAAAQI0AAAECBAAwBAgAANAAABAjQAAAQI0AAAECBAAwBAgAANAAABAjQAAAQI0AAAECBAAwBAgAANAAABAjQAAAQI0AAAECBAAwBAgAANAAABAjQAAAQI0AAAECBAAwBAgAANAAABAjQAAAQI0AAAECBAAwBAgAANAAABAjQAAAQI0AAAECBAAwBAgAANAAABAjQAAAQI0AAAECBAAwBAgAANAAABAjQAAAQI0AAAECBAAwBAgAANAAABAjQAAAQI0AAAECBAAwBAgAANAAABAjQAAAQI0AAAECBAAwBAgAANAAABAjQAAAQI0AAAECBAAwBAgAANAAABAjQAAAQI0AAAECBAAwBAgAANAAABAjQAAAQI0AAAECBAAwBAgAANAAABAjQAAAQI0AAAECBAAwBAgAANAAABAjQAAAQI0AAAECBAAwBAgAANAAABAjQAAAQI0AAAECBAAwBAgAANAAABAjQAAAQI0AAAECBAAwBAgAANAAABAjQAAAQI0AAAECBAAwBAgAANAAABAjQAAAQI0AAAECBAAwBAgAANAAABAjQAAAQI0AAAECBAAwBAgAANAAABAjQAAAQI0AAAECBAAwBAgAANAAABAjQAAAQI0AAAECBAAwBAgAANAAABAjQAAAQI0AAAECBAAwBAgAANAAABAjQAAAQI0AAAECBAAwBAgAANAAABAjQAAAQI0AAAECBAAwBAgAANAAABAjQAAAQI0AAAECBAAwBAgAANAAAB9sjYSgAAAa9JREFUAjQAAAQI0AAAECBAAwBAgAANAAABAjQAAAQI0AAAECBAAwBAgAANAAABAjQAAAQI0AAAECBAAwBAgAANAAABAjQAAAQI0AAAECBAAwBAgAANAAABAjQAAAQI0AAAECBAAwBAgAANAAABAjQAAAQI0AAAECBAAwBAgAANAAABAjQAAAQI0AAAECBAAwBAgAANAAABAjQAAAQI0AAAECBAAwBAgAANAAABAjQAAAQI0AAAECBAAwBAgAANAAABAjQAAAQI0AAAECBAAwBAgAANAAABAjQAAAQI0AAAECBAAwBAgAANAAABAjQAAAQI0AAAECBAAwBAgAANAAABAjQAAAQI0AAAECBAAwBAgAANAAABAjQAAAQI0AAAECBAAwBAgAANAAABAjQAAAQI0AAAECBAAwBAgAANAAABAjQAAAQI0AAAECBAAwBAgAANAAABAjQAAAQI0AAAECBAAwBAgAANAAABAjQAAAQI0AAAECBAAwBAgAANAAABAjQAAAQI0AAAECBAAwBAgAANAAABAjQAAAQI0AAAECBAAwBAgAANAAABAjQAAAT8D+CKTaKCVITCAAAAAElFTkSuQmCC" width="960" height="480" class="img_ev3q"></li><li>此时 rust 会检测当前环境是否满足 rust 安装程序的要求，如果不满足，会提示用户安装对应的程序
<img loading="lazy" src="/my-website/assets/images/windows-rust-install-step-02-4e47372304869a4a2cfab6a7a2cc87f5.png" width="960" height="480" class="img_ev3q"></li><li>我们选择方案 1，此时会拉起 <code>Visual Studio Installer</code> 安装程序，我们直接点击确定进行安装
<img loading="lazy" src="/my-website/assets/images/windows-rust-install-step-03-1f0ff10fd2c068d5fd3e5f2a8a7be0f9.png" width="740" height="555" class="img_ev3q"></li><li>安装完之后需要重启电脑，重启成功之后，我们重新点击 rust 安装程序进行安装，此时检测到的安装环境将满足 rust 安装程序的要求
<img loading="lazy" src="/my-website/assets/images/windows-rust-install-step-04-e928ef7abfd1ae86067d825fa162ecb3.png" width="960" height="480" class="img_ev3q"><blockquote><p>如果看到提示未安装 C++ 构建工具时，需要停止安装，下载安装 Visual Studio 2017 或更高版本，具体安装详见<a href="https://rust-lang.github.io/rustup/installation/windows-msvc.html" target="_blank" rel="noopener noreferrer">官方 Windows 平台安装的文档</a></p></blockquote></li><li>下载 最新版本的 Visual Studio ，点击安装，安装时选择 <code>Desktop Development with C++</code>，安装过程较长，且部分包需要 VPN 才能下载，安装成功后再回头执行 Rust 安装程序就不会看到未安装 <code>C++ Build Tools</code> 的提示了
<img loading="lazy" src="/my-website/assets/images/windows-rust-install-step-05-c625628af97dd07d65c9b33becdf074f.png" width="732" height="685" class="img_ev3q"></li><li>rust 安装程序会提示选择哪种安装方式
<img loading="lazy" src="/my-website/assets/images/windows-rust-install-step-06-01560ccc43fc6b56f5816220c280bc6b.png" width="602" height="688" class="img_ev3q"></li><li>我们选择方式 1 进行安装，安装结束后提示按回车键结束
<img loading="lazy" src="/my-website/assets/images/windows-rust-install-step-07-5db0da7c098279d9fef6a9011087095d.png" width="691" height="541" class="img_ev3q"></li><li>重新打开 cmd，检查 rustc 和 rustup 是否可用
<img loading="lazy" src="/my-website/assets/images/windows-rust-install-step-08-4e5f5e5add7321f04dd76ed5e1a0427c.png" width="778" height="204" class="img_ev3q"></li></ol><p>至此，rust 安装程序就成功了 φ(<!-- -->*<!-- -->￣ 0 ￣)可以开启 rust 之旅了( •̀ ω •́ )✧</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="参考">参考<a href="#参考" class="hash-link" aria-label="参考的直接链接" title="参考的直接链接">​</a></h2><p><a href="https://rustwiki.org/zh-CN/book/title-page.html" target="_blank" rel="noopener noreferrer">Rust 程序设计语言</a></p>]]></content>
        <author>
            <name>Hanbin Che</name>
            <uri>https://github.com/hbche</uri>
        </author>
        <category label="rust" term="rust"/>
        <category label="cargo" term="cargo"/>
        <category label="入门指南" term="入门指南"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[通过 Github Actions 部署 docusaurus 创建的静态网站]]></title>
        <id>https://hbche.github.io/my-website/blog/2023/09/08/deploy-docusaurus</id>
        <link href="https://hbche.github.io/my-website/blog/2023/09/08/deploy-docusaurus"/>
        <updated>2023-09-08T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[记录 静态网站 学习过程]]></summary>
        <content type="html"><![CDATA[<h1></h1>]]></content>
        <author>
            <name>hbche</name>
            <uri>https://github.com/hbche</uri>
        </author>
        <category label="deploy" term="deploy"/>
        <category label="docusaurus" term="docusaurus"/>
        <category label="tutorial" term="tutorial"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[NVM 教程]]></title>
        <id>https://hbche.github.io/my-website/blog/2023/09/04/nvm-tutorial</id>
        <link href="https://hbche.github.io/my-website/blog/2023/09/04/nvm-tutorial"/>
        <updated>2023-09-04T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[记录 NVM 学习过程]]></summary>
        <content type="html"><![CDATA[<h3 class="anchor anchorWithStickyNavbar_LWe7" id="什么是-nvm">什么是 NVM<a href="#什么是-nvm" class="hash-link" aria-label="什么是 NVM的直接链接" title="什么是 NVM的直接链接">​</a></h3><p><a href="https://github.com/nvm-sh/nvm" target="_blank" rel="noopener noreferrer"><img loading="lazy" alt="logo" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48c3ZnIGlkPSJhIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1OTUuMjggMjg1LjA2Ij48ZGVmcz48c3R5bGU+LmJ7c3Ryb2tlOiMwMDA7c3Ryb2tlLWxpbmVjYXA6cm91bmQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS13aWR0aDoycHg7fS5iLC5jLC5ke2ZpbGwtcnVsZTpldmVub2RkO30uY3tmaWxsOiNmZmY7fTwvc3R5bGU+PC9kZWZzPjxwYXRoIGQ9Ik01NjMuOTMsMTYyLjc5YzAsMTYuMjEsLjAyLDMyLjQzLDAsNDguNjQtLjAxLDYuNjUtMi4zMyw3Ljk1LTguMTQsNC42NC0xMS42MS02LjYxLTIzLjE3LTEzLjMyLTM0Ljg1LTE5LjgxLTQuMi0yLjMzLTYuMDktNS40Mi02LjAxLTEwLjMyLC4yMi0xNC4yNi0uMDItMjguNTMsLjEzLTQyLjgsLjA1LTUuMS0xLjc2LTguNjMtNi4zNy0xMS00LjYxLTIuMzctOS4wNi01LjA3LTEzLjUxLTcuNzItMy4zMy0xLjk5LTYuNTctMi4xLTkuOTMtLjE0LTUuMDUsMi45NC0xMC4xMSw1Ljg0LTE1LjE4LDguNzQtMi45NSwxLjY5LTQuMzIsNC4wMi00LjMxLDcuNiwuMDcsMjMuNDgtLjAzLDQ2Ljk1LS4wOSw3MC40My0uMDIsNy4xOC0yLjIyLDguNDMtOC41MSw0Ljg0LTExLjQ5LTYuNTYtMjIuOTMtMTMuMjEtMzQuNS0xOS42NC00LjIxLTIuMzQtNi4wOC01LjQzLTYtMTAuMzIsLjIyLTE0LjI2LS4wMi0yOC41MywuMTMtNDIuOCwuMDUtNS4xLTEuNzgtOC42My02LjM4LTEwLjk5LTQuNS0yLjMtOC44Ni00Ljg5LTEzLjE3LTcuNTQtMy43NC0yLjMtNy4yNC0yLjIxLTEwLjk1LC4wNi00LjMxLDIuNjQtOC42OCw1LjIyLTEzLjE3LDcuNTUtNC40MiwyLjMtNi4zMSw1LjY2LTYuMjUsMTAuNjUsLjE2LDE0LjUzLS4wNCwyOS4wNSwuMTIsNDMuNTgsLjA1LDQuNDEtMS42Myw3LjMxLTUuNDMsOS40NS0xMi4xLDYuOC0yNC4xMSwxMy43Ny0zNi4xNywyMC42My00Ljc4LDIuNzItNy40LDEuMjEtNy40MS00LjM0LS4wNi0zMi45NC0uMDYtNjUuODktLjE0LTk4LjgzLDAtNC4wMywxLjU4LTYuODgsNS4xMS04Ljg5LDIxLjI5LTEyLjE2LDQyLjU2LTI0LjM2LDYzLjgtMzYuNiwzLjUxLTIuMDIsNi43Ni0xLjk3LDEwLjI2LC4wNiwxMy43LDcuOTMsMjcuNDgsMTUuNzEsNDEuMTYsMjMuNjgsMi4wOCwxLjIxLDMuNTQsMS4yLDUuNjEsMCwxMy4zMy03Ljc5LDI2LjgtMTUuMzMsNDAuMS0yMy4xNiw0LjI4LTIuNTIsOC4wNC0yLjU2LDEyLjM2LS4wNSwyMC42NCwxMiw0MS4zNSwyMy44Nyw2Mi4xLDM1LjY1LDQuMDksMi4zMiw1LjgyLDUuNDgsNS43OSwxMC4xMS0uMTEsMTYuMjEtLjA0LDMyLjQzLS4wNCw0OC42NGgtLjE0WiIvPjxwYXRoIGQ9Ik0zMS4yMywxNjIuNDljMC0xNS45NSwuMTEtMzEuOS0uMDctNDcuODUtLjA2LTQuOTcsMS43LTguMjQsNi4wNy0xMC43MiwyMC44OC0xMS44Myw0MS42OC0yMy44LDYyLjQ0LTM1LjgzLDMuNzgtMi4xOSw3LjEyLTIuMjcsMTAuOTItLjA3LDIwLjg3LDEyLjEsNDEuNzksMjQuMTMsNjIuNzcsMzYuMDQsNC4wOCwyLjMyLDUuODgsNS40Miw1Ljg2LDEwLjA2LS4xMiwzMi40Mi0uMTIsNjQuODQtLjE5LDk3LjI2LS4wMSw2LjU5LTIuNDQsOC04LjExLDQuNzYtMTEuNzEtNi42OS0yMy4zOC0xMy40Ny0zNS4xNi0yMC4wNC0zLjk1LTIuMi01Ljc2LTUuMS01LjcxLTkuNjgsLjE2LTE0LjM5LS4wNC0yOC43OSwuMTEtNDMuMTgsLjA1LTUuMDctMS42Ni04LjY1LTYuMy0xMS4wMy00LjczLTIuNDItOS4yNy01LjIxLTEzLjg2LTcuOS0zLjIxLTEuODktNi4zNC0xLjkyLTkuNTYtLjAzLTQuOTIsMi44OS05Ljg0LDUuNzgtMTQuODUsOC41Mi0zLjg4LDIuMTItNS4zNCw1LjMxLTUuMzIsOS41OSwuMDcsMTQuNTItLjEsMjkuMDUsLjEsNDMuNTcsLjA3LDQuODgtMS43Niw3Ljk2LTYsMTAuMzEtMTEuNjksNi40OC0yMy4yMiwxMy4yMS0zNC44MiwxOS44NC01LjcxLDMuMjYtOC4yMSwxLjg4LTguMjItNC42LS4wMi0xNi4zNCwwLTMyLjY4LDAtNDkuMDJoLS4wOVoiLz48cG9seWdvbiBjbGFzcz0iZCIgcG9pbnRzPSIxNTcuMjUgMTAzLjMxIDE0OS41IDEwMy4zMSAxNTQuMDYgMTExLjE5IDE2MS44IDExMS4xOSAxNTcuMjUgMTAzLjMxIDE1Ny4yNSAxMDMuMzEiLz48cG9seWdvbiBjbGFzcz0iYiIgcG9pbnRzPSIyMTQuMzQgMTI3LjkzIDIxMi42MyAxMjQuODIgMjA3LjQ0IDExNS45MiAyMDEuNzEgMTE1Ljk5IDIwMy4yOCAxMTguNjkgMTg4LjY4IDExOC43NyAxODUuNDggMTEzLjI2IDE3NC43MyAxMTMuMzQgMjMyLjY3IDIwNC40MiAyNTQuNCAxNjUuNjEgMjM2Ljk2IDEzNS42OCAyMzUuMTkgMTMyLjYzIDIzMS4xMyAxMjUuNjYgMjMxLjEzIDEyNS42NiAyMTQuMzQgMTI3LjkzIi8+PHBhdGggZD0iTTI2OC4yMywxMTkuMjJjNC41OC03Ljg5LDkuMTYtMTUuNzcsMTMuNjYtMjMuNywuOTgtMS43MiwyLjIzLTIuNDMsNC4yLTIuNDIsMTMuMzgsLjA1LDI2Ljc2LC4wMiw0MC4xNCwuMDMsMy44MSwwLDQuNzUsMS40OCwzLjIxLDQuOTgtNC4xOCw3LjA5LTguNDUsMTQuMTMtMTIuMjksMjEuNDItNC40OSw3LjY2LTksMTUuMy0xMy40NSwyMi45OC05Ljk0LDE3LjE2LTE5Ljc1LDM0LjQtMjkuODMsNTEuNDgtNC44NSw4LjIyLTkuNjksMTYuNDUtMTUuMjYsMjQuMjItMS4yMSwxLjY4LTIuNDUsMy4zNy0zLjg2LDQuODgtMy41OCwzLjgyLTYuNjMsMy43Ny0xMC4yMy0uMDUtMS43My0xLjgzLTcuMTYtOS43OS00LjI2LTUuMTMtNC43Mi03LjQtMTAuMzktMTUuODItMTUuMDctMjMuMjMsMS41Mi0zLjUzLDE3Ljk5LTMzLjMsMjIuMzEtNDAuNzUsLjM0LS41OCwxNC40NC0yMy44OCwyMC43Mi0zNC43MVoiLz48cG9seWxpbmUgY2xhc3M9ImMiIHBvaW50cz0iMjI1LjIgMTk0LjY4IDI0OC4xNiAxNTIuODMgMjQxLjgyIDE0Mi4xIi8+PGc+PHBvbHlnb24gY2xhc3M9ImIiIHBvaW50cz0iMTgwLjI0IDg5Ljk2IDE3My44NCA5MC4wOSAxNzcuNzQgOTYuNTMgMTgwLjAzIDk2LjQ4IDE4My42NiAxMDIuNDggMTk0LjE1IDEwMi4yNiAxODcuNzYgOTEuNzIgMTgxLjM5IDkxLjg1IDE4MC4yNCA4OS45NiAxODAuMjQgODkuOTYiLz48cG9seWdvbiBjbGFzcz0iYiIgcG9pbnRzPSIxNzkuMzMgNTkuMDcgMTczLjA5IDU5LjIgMTc2Ljg5IDY1LjQ3IDE4My4xMyA2NS4zNCAxNzkuMzMgNTkuMDcgMTc5LjMzIDU5LjA3Ii8+PHBvbHlnb24gY2xhc3M9ImIiIHBvaW50cz0iMTY4LjEzIDY3LjkzIDE2Mi44NyA2OC4wNCAxNjYuMDcgNzMuMzIgMTcxLjMzIDczLjIxIDE2OC4xMyA2Ny45MyAxNjguMTMgNjcuOTMiLz48cG9seWdvbiBjbGFzcz0iYiIgcG9pbnRzPSIxOTAuNTggNDguMzggMTg2LjE3IDQ4LjQ3IDE4OC40OCA1Mi4yOCAxOTIuODkgNTIuMTkgMTkwLjU4IDQ4LjM4IDE5MC41OCA0OC4zOCIvPjxwb2x5Z29uIGNsYXNzPSJiIiBwb2ludHM9IjE4MC4zNCA3Ny4xMiAxNzQuOCA3Ny4yNCAxNzcuNyA4Mi4wMyAxODMuMjQgODEuOTEgMTgwLjM0IDc3LjEyIDE4MC4zNCA3Ny4xMiIvPjxwb2x5Z29uIGNsYXNzPSJiIiBwb2ludHM9IjIwNy41MSA4MC4xOCAxOTguNTUgODAuMzcgMTk3LjExIDc4IDE4OC45OSA3OC4xNyAxOTMuMjMgODUuMTggMTk4Ljc5IDg1LjA3IDIwMyA5Mi4wMiAyMTQuNTQgOTEuNzggMjA3LjUxIDgwLjE4IDIwNy41MSA4MC4xOCIvPjxwb2x5Z29uIGNsYXNzPSJiIiBwb2ludHM9IjE5OC4wNSA2NC41OSAxOTAuMjIgNjQuNzYgMTk0LjMyIDcxLjU0IDIwMi4xNiA3MS4zNyAxOTguMDUgNjQuNTkgMTk4LjA1IDY0LjU5Ii8+PHBvbHlnb24gY2xhc3M9ImIiIHBvaW50cz0iMTYzLjU0IDUwLjI2IDE1OS45MyA1MC4zNCAxNjEuODIgNTMuNDYgMTY1LjQzIDUzLjM4IDE2My41NCA1MC4yNiAxNjMuNTQgNTAuMjYiLz48cG9seWdvbiBjbGFzcz0iYiIgcG9pbnRzPSIyMjIuOTkgMTA0LjI0IDIwOC42NyAxMDQuNTUgMjExLjUxIDEwOS4yMyAyMTUuODkgMTA5LjE0IDIxOC41MyAxMTMuNDggMjI4LjQ2IDExMy4yNyAyMjIuOTkgMTA0LjI0IDIyMi45OSAxMDQuMjQiLz48L2c+PHBvbHlnb24gY2xhc3M9ImIiIHBvaW50cz0iMTY2Ljg4IDc5Ljc3IDE2Mi40NiA3OS44NiAxNjQuNzcgODMuNjcgMTY5LjE4IDgzLjU4IDE2Ni44OCA3OS43NyAxNjYuODggNzkuNzciLz48L3N2Zz4=#logo-width" width="595" height="285" class="img_ev3q"></a></p><p>nvm 全称 Node Version Manager，是一种 nodejs 版本管理工具，它允许我们只通过简单的命令行实现“快速”安装和使用不同版本的 nodejs。</p><div class="language-cmd codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockTitle_Ktv7">命令行示例</div><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-cmd codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">$ nvm use 16</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">Now using node v16.9.1 (npm v7.21.1)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">$ node -v</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">v16.9.1</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">$ nvm use 14</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">Now using node v14.18.0 (npm v6.14.15)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">$ node -v</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">v14.18.0</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">$ nvm install 12</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">Now using node v12.22.6 (npm v6.14.5)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">$ node -v</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">v12.22.6</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="nvm-安装">NVM 安装<a href="#nvm-安装" class="hash-link" aria-label="NVM 安装的直接链接" title="NVM 安装的直接链接">​</a></h3><p>当前只记录 Windows 环境下的安装教程，其他平台的参照 <a href="https://github.com/nvm-sh/nvm#installing-and-updating" target="_blank" rel="noopener noreferrer">Installing and Updating</a>。</p><p>访问 <a href="https://github.com/coreybutler/nvm-windows/releases" target="_blank" rel="noopener noreferrer">nvm-windows</a> 仓库，下载指定版本的 <code>nvm-setup.exe</code> 安装包点击安装即可。
<img loading="lazy" src="/my-website/assets/images/nvm-setup-01-ea1ec8c5fd531edf80c07d08690b65e5.png" width="499" height="392" class="img_ev3q">
<img loading="lazy" src="/my-website/assets/images/nvm-setup-02-72bd9fcd667ad3fc950ea08de02fc80c.png" width="497" height="389" class="img_ev3q">
<img loading="lazy" src="/my-website/assets/images/nvm-setup-03-25d5164e75205284db3a0b17deb664ce.png" width="497" height="390" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="nvm-常见命令使用">NVM 常见命令使用<a href="#nvm-常见命令使用" class="hash-link" aria-label="NVM 常见命令使用的直接链接" title="NVM 常见命令使用的直接链接">​</a></h3><p>nvm 帮助文档</p><div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">nvm</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>输出的帮助文档如下：</p><p>Running version 1.1.7.</p><table><thead><tr><th>Usage <!-- -->&nbsp;<!-- -->&nbsp;<!-- -->&nbsp;<!-- -->&nbsp;<!-- -->&nbsp;<!-- -->&nbsp;<!-- -->&nbsp;<!-- -->&nbsp;<!-- -->&nbsp;<!-- -->&nbsp;<!-- -->&nbsp;<!-- -->&nbsp;<!-- -->&nbsp;<!-- -->&nbsp;<!-- -->&nbsp;<!-- -->&nbsp;<!-- -->&nbsp;<!-- -->&nbsp;<!-- -->&nbsp;<!-- -->&nbsp;<!-- -->&nbsp;<!-- -->&nbsp;<!-- -->&nbsp;<!-- -->&nbsp;<!-- -->&nbsp;<!-- -->&nbsp;<!-- -->&nbsp;<!-- -->&nbsp;<!-- -->&nbsp;<!-- -->&nbsp;<!-- -->&nbsp;<!-- -->&nbsp;<!-- -->&nbsp;<!-- -->&nbsp;<!-- -->&nbsp;<!-- -->&nbsp;<!-- -->&nbsp;<!-- -->&nbsp;<!-- -->&nbsp;<!-- -->&nbsp;<!-- -->&nbsp;<!-- -->&nbsp;<!-- -->&nbsp;<!-- -->&nbsp;<!-- -->&nbsp;<!-- -->&nbsp;<!-- -->&nbsp;<!-- -->&nbsp;<!-- -->&nbsp;<!-- -->&nbsp;</th><th>Description</th></tr></thead><tbody><tr><td><code>vm arch</code></td><td><code>Show if node is running in 32 or 64 bit mode.</code></td></tr><tr><td><code>nvm install &lt;version&gt; [arch]</code></td><td><code>The version can be a node.js version or "latest" for the latest stable version. Optionally specify whether to install the 32 or 64 bit version (defaults to system arch).Set [arch] to "all" to install 32 AND 64 bit versions.Add --insecure to the end of this command to bypass SSL validation of the remote download server.</code></td></tr><tr><td><code>nvm list [available]</code></td><td><code>List the node.js installations. Type "available" at the end to see what can be installed. Aliased as ls.</code></td></tr><tr><td><code>nvm on</code></td><td><code>Enable node.js version management.</code></td></tr><tr><td><code>nvm off</code></td><td><code>Disable node.js version management.</code></td></tr><tr><td><code>nvm proxy [url]</code></td><td><code>Set a proxy to use for downloads. Leave [url] blank to see the current proxy.Set [url] to "none" to remove the proxy.</code></td></tr><tr><td><code>nvm node_mirror [url]</code></td><td><code>Set the node mirror. Defaults to https://nodejs.org/dist/. Leave [url] blank to use default url.</code></td></tr><tr><td><code>nvm npm_mirror [url]</code></td><td><code>Set the npm mirror. Defaults to https://github.com/npm/cli/archive/. Leave [url] blank to default url.</code></td></tr><tr><td><code>nvm uninstall &lt;version&gt;</code></td><td><code>The version must be a specific version.</code></td></tr><tr><td><code>nvm use [version] [arch]</code></td><td><code>Switch to use the specified version. Optionally specify 32/64bit architecture.nvm use &lt;arch&gt; will continue using the selected version, but switch to 32/64 bit mode.</code></td></tr><tr><td><code>nvm root [path]</code></td><td><code>Set the directory where nvm should store different versions of node.js.If &lt;path&gt; is not set, the current root will be displayed.</code></td></tr><tr><td><code>nvm version</code></td><td><code>Displays the current running version of nvm for Windows. Aliased as v.</code></td></tr></tbody></table><p>查看当前远程镜像仓库中可用的 node 版本</p><div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">nvm list available</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><blockquote><p>如果遇到如下错误可重新运行一次<code>nvm list available</code></p></blockquote><div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">Could not retrieve https://npmmirror.com/mirrors/node/index.json.</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">Get "https://cdn.npmmirror.com/binaries/node/index.json": read tcp 10.106.22.43:52214-&gt;111.39.146.89:443: wsarecv: An existing connection was forcibly closed by the remote host.</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>输出结果如下：</p><table><thead><tr><th>CURRENT</th><th>LTS</th><th>OLD STABLE</th><th>OLD UNSTABLE</th></tr></thead><tbody><tr><td>20.6.0</td><td>18.17.1</td><td>0.12.18</td><td>0.11.16</td></tr><tr><td>20.5.1</td><td>18.17.0</td><td>0.12.17</td><td>0.11.15</td></tr><tr><td>20.5.0</td><td>18.16.1</td><td>0.12.16</td><td>0.11.14</td></tr><tr><td>20.4.0</td><td>18.16.0</td><td>0.12.15</td><td>0.11.13</td></tr><tr><td>20.3.1</td><td>18.15.0</td><td>0.12.14</td><td>0.11.12</td></tr><tr><td>20.3.0</td><td>18.14.2</td><td>0.12.13</td><td>0.11.11</td></tr><tr><td>20.2.0</td><td>18.14.1</td><td>0.12.12</td><td>0.11.10</td></tr><tr><td>20.1.0</td><td>18.14.0</td><td>0.12.11</td><td>0.11.9</td></tr><tr><td>20.0.0</td><td>18.13.0</td><td>0.12.10</td><td>0.11.8</td></tr><tr><td>19.9.0</td><td>18.12.1</td><td>0.12.9</td><td>0.11.7</td></tr><tr><td>19.8.1</td><td>18.12.0</td><td>0.12.8</td><td>0.11.6</td></tr><tr><td>19.8.0</td><td>16.20.2</td><td>0.12.7</td><td>0.11.5</td></tr><tr><td>19.7.0</td><td>16.20.1</td><td>0.12.6</td><td>0.11.4</td></tr><tr><td>19.6.1</td><td>16.20.0</td><td>0.12.5</td><td>0.11.3</td></tr><tr><td>19.6.0</td><td>16.19.1</td><td>0.12.4</td><td>0.11.2</td></tr><tr><td>19.5.0</td><td>16.19.0</td><td>0.12.3</td><td>0.11.1</td></tr><tr><td>19.4.0</td><td>16.18.1</td><td>0.12.2</td><td>0.11.0</td></tr><tr><td>19.3.0</td><td>16.18.0</td><td>0.12.1</td><td>0.9.12</td></tr><tr><td>19.2.0</td><td>16.17.1</td><td>0.12.0</td><td>0.9.11</td></tr><tr><td>19.1.0</td><td>16.17.0</td><td>0.10.48</td><td>0.9.10</td></tr></tbody></table><p>This is a partial list. For a complete list, visit <a href="https://nodejs.org/en/download/releases" target="_blank" rel="noopener noreferrer">https://nodejs.org/en/download/releases</a></p><p>下载、编译并安装<strong>指定</strong>版本的 node</p><div class="language-cmd codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-cmd codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">nvm install 18.17.1</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>输出可能如下：</p><div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">Downloading node.js version 18.17.1 (64-bit)...</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">Extracting node and npm...</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">Complete</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">npm v9.6.7 installed successfully.</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">Installation complete. If you want to use this version, type</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">nvm use 18.17.1</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>选择当前使用的 node 版本</p><div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">nvm use 18.17.1</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>输入如下：</p><div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">Now using node v18.17.1 (64-bit)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>查看本地已经安装的可用 node 版本</p><div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">nvm list</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>输出结果可能如下：</p><div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token list punctuation" style="color:rgb(248, 248, 242)">*</span><span class="token plain"> 18.17.1 (Currently using 64-bit executable)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">  16.17.0</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="修改-nvm-镜像路径">修改 NVM 镜像路径<a href="#修改-nvm-镜像路径" class="hash-link" aria-label="修改 NVM 镜像路径的直接链接" title="修改 NVM 镜像路径的直接链接">​</a></h3><ol><li>方式一：</li></ol><p>直接修改 nvm 安装目录下 <code>setting.txt</code>文件</p><p>修改前：</p><div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">root: D:\devTool\nvm</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">path: D:\devTool\nvm\nodejs</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>修改后：</p><div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">root: D:\devTool\nvm</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">path: D:\devTool\nvm\nodejs</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">node_mirror: https://npmmirror.com/mirrors/node/</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">npm_mirror: https://npmmirror.com/mirrors/npm/</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>方式二：</li></ol><p>命令行修改</p><div class="language-markdown codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#F8F8F2;--prism-background-color:#282A36"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-markdown codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#F8F8F2"><span class="token plain">nvm node_mirror https://npmmirror.com/mirrors/node/</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">nvm npm_mirror https://npmmirror.com/mirrors/npm/</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="nvm-问题补充">NVM 问题补充<a href="#nvm-问题补充" class="hash-link" aria-label="NVM 问题补充的直接链接" title="NVM 问题补充的直接链接">​</a></h3><p>待补充</p>]]></content>
        <author>
            <name>Hanbin Che</name>
            <uri>https://github.com/hbche</uri>
        </author>
        <category label="nvm" term="nvm"/>
        <category label="node" term="node"/>
        <category label="tutorial" term="tutorial"/>
    </entry>
</feed>